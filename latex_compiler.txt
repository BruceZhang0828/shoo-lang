
\\subsection*{shoo.ml}
\\begin{mdframed}[hidealllines=true,backgroundcolor=blue!20]
\\begin{lstlisting}
(* Top-level of the Shoo compiler: scan & parse the input,
   check the resulting AST and generate an SAST from it, generate LLVM IR,
   and dump the module *)

type action = Ast | Sast | Lsast | LLVM_IR | Compile

let () =
  let action = ref Compile in
  let set_action a () = action := a in
  let speclist = [
    ("-a", Arg.Unit (set_action Ast), "Print the AST");
    ("-s", Arg.Unit (set_action Sast), "Print the SAST");
    ("-ls", Arg.Unit (set_action Lsast), "Print the LSAST");
    ("-l", Arg.Unit (set_action LLVM_IR), "Print the generated LLVM IR");
    ("-c", Arg.Unit (set_action Compile),
      "Check and print the generated LLVM IR (default)");
  ] in  
  let usage_msg = "usage: ./shoo.native [-a|-s|-l|-c] [file.shoo]" in
  let channel = ref stdin in
  Arg.parse speclist (fun filename -> channel := open_in filename) usage_msg;
  
  let lexbuf = Lexing.from_channel !channel in
  let ast = Parser.program Scanner.token lexbuf in  
  match !action with
    Ast -> print_string (Ast.string_of_program ast)
  | _ ->
    let sast = Semant.check_program ast in
    let lsast = Lift.lift sast in
    match !action with
      Ast     -> print_string (Ast.string_of_program ast)
    | Sast    -> print_string (Sast.string_of_sprogram sast)
    | Lsast   -> print_string (Lift.string_of_lsast lsast)
    | LLVM_IR -> print_string (Llvm.string_of_llmodule (Codegen.translate lsast))
    | Compile -> let m = Codegen.translate lsast in
      Llvm_analysis.assert_valid_module m;
      print_string (Llvm.string_of_llmodule m)
\\end{lstlisting}
\\end{mdframed}
\\subsection*{scanner.mll}
\\begin{mdframed}[hidealllines=true,backgroundcolor=blue!20]
\\begin{lstlisting}
{ open Parser }

rule token = parse
  [' ' '\t' '\r' '\n'] { token lexbuf } (* Whitespace *)
| "//" { linec lexbuf } (* Single-line Comments *)
| "/*" { comment 0 lexbuf } (* Multi-line Comments *)
| ';' { SEMI }
| '(' { LPAREN }
| ')' { RPAREN }
| '{' { LBRACKET }
| '}' { RBRACKET }
| '[' { LSQBRACE }
| ']' { RSQBRACE }
| '.' { DOT }
| ',' { COMMA }
| ':' { COLON }
| '+' { PLUS }
| '-' { MINUS }
| '*' { TIMES }
| '%' { MOD }
| '/' { DIVIDE }
| "++" { INCREMENT }
| "--" { DECREMENT }
| "==" { EQ }
| '=' { ASSIGN }
| "!=" { NEQ }
| "!" { NOT }
| "<=" { LEQ }
| '<' { LT }
| ">=" { GEQ }
| ">" { GT }
| "&&" { AND }
| "||" { OR }
| "function" { FUNCTION }
| "func" { FUNC }
| "int" { INT }
| "float" { FLOAT }
| "string" { STRING }
| "bool" { BOOL }
| "void" { VOID }
| "return" { RETURN }
| "elif" { ELIF }
| "if" { IF }
| "else" { ELSE }
| "for" { FOR }
| "while" { WHILE }
| "struct" { STRUCT }
| "array" { ARRAY }
| "in" { IN }
| "new" { NEW }
| "true"|"false" as lxm { BOOLLIT(bool_of_string lxm) }
| ['0'-'9']+ as lxm { INTLIT(int_of_string lxm) }
| ['0'-'9']*"."['0'-'9']+ as lxm { FLOATLIT(lxm) }
| ['a'-'z']['a'-'z' 'A'-'Z' '0'-'9' '_']* as lxm { ID(lxm) }
| ['A'-'Z']['a'-'z' 'A'-'Z' '0'-'9']* as lxm { STRUCTID(lxm) }
| '"' { str (Buffer.create 16) lexbuf }
| eof { EOF }
| _ as char { raise (Failure("illegal character " ^ Char.escaped char)) }

and comment level = parse
  "*/" { match level with 0 -> token lexbuf | _ -> comment (level - 1) lexbuf }
| "/*" { comment (level + 1) lexbuf }
| _ { comment level lexbuf }

and linec = parse
  '\n' { token lexbuf }
| eof {token lexbuf}
| _ { linec lexbuf }

and str buf = parse
  '"' { STRLIT(Buffer.contents buf) }
| [^ '"'] { Buffer.add_string buf (Lexing.lexeme lexbuf); str buf lexbuf }
\\end{lstlisting}
\\end{mdframed}
\\subsection*{ast.ml}
\\begin{mdframed}[hidealllines=true,backgroundcolor=blue!20]
\\begin{lstlisting}
module StringMap = Map.Make (String)

type size =
  Fixed of int
| Param of string

type op = 
  Add 
| Sub 
| Mult 
| Div 
| Equal
| Mod
| Neq 
| Less 
| Leq 
| Greater
| Geq 
| And 
| Or

type uop = 
  Neg 
| Not

type pop = 
| Dec 
| Inc

type typ =
  Void
| Int
| Float
| Bool
| String
| Func of func_typ
| Struct of struct_typ
| Array of typ
| ABSTRACT

and func_typ = {
  param_typs: typ list;
  return_typ: typ;
}

and struct_typ = {
  struct_name: string;
  members: (typ * expr option) StringMap.t;
  incomplete: bool;
}

and bind = typ * string

and newable =
  NArray of typ * expr
| NStruct of string

and expr =
  IntLit of int
| FloatLit of string 
| StrLit of string
| BoolLit of bool
| ArrayLit of expr list
| Id of string
| Binop of expr * op * expr
| Unop of uop * expr
| Pop of expr * pop 
| Assign of expr * expr
| FCall of expr * expr list
| FExpr of fexpr
| StructInit of (string * expr) list
| ArrayAccess of expr * expr
| ArrayLength of expr
| Dot of expr * string
| New of newable
| Noexpr

and fexpr = {
  name : string;
  typ : typ;
  params: bind list;
  body : stmt list
}

and stmt =
  Expr of expr
| Destruct of stmt list * expr * string
| VDecl of typ * string * expr option
| Return of expr
| If of expr * stmt list * stmt list
| ForLoop of (stmt option) * (expr option) * (expr option) * stmt list
| WhileLoop of (expr option) * stmt list
| StructDef of string * (typ * string * expr option) list

type program = stmt list

let fmt_one name v = String.concat "" [name; "("; v; ")"]
let fmt_two name v1 v2 = String.concat "" [name; "("; v1; ","; v2; ")"]
let fmt_three name v1 v2 v3 = String.concat "" 
  [name; "("; v1; ","; v2; ","; v3; ")"]
let fmt_four name v1 v2 v3 v4 = String.concat "" 
  [name; "("; v1; ","; v2; ","; v3; ","; v4; ")"]
let fmt_five name v1 v2 v3 v4 v5 = String.concat "" 
  [name; "("; v1; ","; v2; ","; v3; ","; v4; ","; string_of_bool v5; ")"]

let fmt_list l =
  let items = String.concat ";" l in 
  String.concat "" ["["; items; "]"]

let rec fmt_typ = function
  Void -> "void"
  | Func(e) -> "func(" ^ (String.concat "," (List.map fmt_typ e.param_typs)) 
    ^ "; " ^ (fmt_typ e.return_typ) ^ ")" 
  | Int -> "int"
  | Float -> "float"
  | Bool -> "bool"
  | String -> "string"
  | Struct(st) -> fmt_three "struct" st.struct_name 
        (fmt_list (List.map (fun (k, _) -> k) 
            (StringMap.bindings st.members))) 
        (string_of_bool st.incomplete)
  | Array(t) -> fmt_one "array" (fmt_typ t)
  | ABSTRACT -> "ABSTRACT"

and fmt_typ_list l =
  let typs = List.map fmt_typ l in
  fmt_list typs

let fmt_op = function
    Add -> "+"
  | Sub -> "-"
  | Mult -> "*"
  | Div -> "/"
  | Mod -> "%"
  | Equal -> "=="
  | Neq -> "!="
  | Less -> "<"
  | Leq -> "<="
  | Greater -> ">"
  | Geq -> ">="
  | And -> "&&"
  | Or -> "||"

let fmt_uop = function 
  Neg -> "-"
| Not -> "!"

let fmt_pop = function
  Inc -> "++"
| Dec -> "--"

let fmt_params l =
  let fmt_p = function
    (t, n) -> String.concat "" ["("; fmt_typ t; ", "; n; ")"] in
  fmt_list (List.map fmt_p l)

let rec fmt_expr = function
  IntLit(l) -> fmt_one "IntLit" (string_of_int l)
| FloatLit(l) -> fmt_one "FloatLit" l
| StrLit(l) -> fmt_one "StrLit"  l
| BoolLit(l) -> fmt_one "BoolLit" (string_of_bool l)
| Id(s) -> fmt_one "Id" s
| Binop(e1, o, e2) -> fmt_three "Binop" (fmt_expr e1) (fmt_op o) (fmt_expr e2)
| Unop(uo, e) -> fmt_two "Unop" (fmt_uop uo) (fmt_expr e)
| Pop(e, po) -> fmt_two "Pop" (fmt_expr e) (fmt_pop po)
| Assign(e1, e2) -> fmt_two "Assign" (fmt_expr e1) (fmt_expr e2)
| ArrayAccess(s, e) -> fmt_two "ArrayAccess" (fmt_expr s) (fmt_expr e)
| Dot(e, s) -> fmt_two "Dot" (fmt_expr e) s
| FCall(_, _) -> "FCall"
(* below actually is parsed with {name = e.name; param = e.params;
 * typ = e.typ; body = e.body}. See test programs for examples. *)
| FExpr(e) -> fmt_three "FExpr" (fmt_params e.params) 
        (fmt_typ e.typ) (fmt_stmt_list e.body)
| StructInit(l) -> fmt_one "StructInit" (fmt_init l)
| ArrayLit(l) -> fmt_one "ArrayLit" (fmt_list (List.map fmt_expr l))
| New(t) -> fmt_one "New" (fmt_n t)
| Noexpr -> ""
| ArrayLength(e) -> fmt_one "ArrayLength" (fmt_expr e)

and fmt_n = function
  NArray(t, s) -> fmt_two "NArray" (fmt_typ t) (fmt_expr s)
| NStruct(n) -> fmt_one "NStruct" n

and fmt_members l =
  let fmt_m = function
    (t, n, None) -> fmt_three "" (fmt_typ t) n "None"
  | (t, n, Some(e)) -> fmt_three "" (fmt_typ t) n (fmt_expr e) in
  fmt_list (List.map fmt_m l)

and fmt_init l =
 let fmt_i (n, e) = fmt_two "" n (fmt_expr e) in
 fmt_list (List.map fmt_i l)

and fmt_stmt = function
  Expr(e) -> fmt_expr e
| Destruct(_, _, _) -> "Destruct"
| Return(e) -> fmt_one "Return" (fmt_expr e)
| VDecl (t, n, l) -> fmt_three "VDecl" (fmt_typ t) n (match l with 
  None -> "" | Some(e) -> fmt_expr e)
| ForLoop (init, e2, e3, s) -> 
  fmt_four "ForLoop" 
  (match init with None -> "" | Some(s) -> fmt_stmt s)
  (fmt_opt_expr e2) 
  (fmt_opt_expr e3) (fmt_stmt_list s)
| WhileLoop (e, s) ->
  fmt_two "WhileLoop" (fmt_opt_expr e) (fmt_stmt_list s)
| StructDef(n, m) -> fmt_two "StructDef" n (fmt_members m)
| If(e, tL, fL) -> fmt_three "If" (fmt_expr e) (fmt_stmt_list tL) 
  (fmt_stmt_list fL)

and fmt_stmt_list l =
  let stmts = List.map fmt_stmt l in
  String.concat "\n" stmts

and fmt_opt_expr = function
  None -> ""
| Some(e) -> fmt_expr e

let string_of_program ast =
  fmt_stmt_list ast
\\end{lstlisting}
\\end{mdframed}
\\subsection*{parser.mly}
\\begin{mdframed}[hidealllines=true,backgroundcolor=blue!20]
\\begin{lstlisting}
%{
  open Ast
  module StringMap = Map.Make (String)
%}

%token SEMI ASSIGN INT FLOAT STRING BOOL FUNC LPAREN RPAREN LBRACKET RBRACKET
%token PLUS MINUS TIMES DIVIDE MOD ASSIGN NOT DECREMENT INCREMENT
%token EQ NEQ LT LEQ GT GEQ TRUE FALSE AND OR DOT
%token FOR WHILE COMMA RETURN VOID STRUCT COLON IN ARRAY LT GT LSQBRACE RSQBRACE
%token NEW FUNCTION IF ELIF ELSE
%token <int> INTLIT
%token <string> FLOATLIT
%token <bool> BOOLLIT
%token <string> ID
%token <string> STRUCTID
%token <string> STRLIT
%token EOF

%nonassoc NOELSE
%nonassoc ELSE
%right ASSIGN
%left OR
%left AND
%left EQ NEQ
%left LT GT LEQ GEQ
%left PLUS MINUS NEG
%left TIMES DIVIDE MOD
%right NOT
%right INCREMENT DECREMENT
%left DOT

%start program
%type <Ast.program> program

%%

program: stmt_list EOF { List.rev $1 }

stmt_list:
  { [] }
| stmt_list stmt { $2 :: $1 }

stmt:
  expr SEMI { Expr $1 }
| LBRACKET destruct RBRACKET ASSIGN expr SEMI { Destruct(List.rev $2, $5, "") }
| typ ID opt_init SEMI { VDecl($1, $2, $3) }
| RETURN expr_opt SEMI { Return($2) }
| FUNCTION ID LPAREN params_opt RPAREN ret_typ LBRACKET stmt_list RBRACKET {
  VDecl(Func({ param_typs = List.map (fun (ty, _) -> ty) $4; return_typ = $6 }), 
    $2, Some(FExpr({ name = $2; typ = $6; params = $4; body = List.rev $8 })))
  }
| FOR LPAREN opt_loop_init SEMI opt_expr SEMI opt_expr RPAREN LBRACKET 
    stmt_list RBRACKET { ForLoop($3, $5, $7, List.rev $10) }
| FOR LPAREN typ ID IN expr RPAREN LBRACKET stmt_list RBRACKET {

    If(Binop(FCall(Id("length"), [$6]), Greater, IntLit(0)), [
      VDecl(Int, "_len", Some(FCall(Id("length"), [$6])));
      ForLoop(
        Some(VDecl(Int, "_i", Some(IntLit(0)))),
        Some(Binop(Id("_i"), Less, Id("_len"))),
        Some(Pop(Id("_i"), Inc)),
        [VDecl($3, $4, Some(ArrayAccess($6, Id("_i"))))] @ (List.rev $9))
    ], [])
  
  }
| WHILE LPAREN opt_expr RPAREN LBRACKET stmt_list RBRACKET { 
  ForLoop(None, $3, None, List.rev $6) }
| STRUCT STRUCTID LBRACKET mems_opt RBRACKET { StructDef($2, $4) }
| IF LPAREN expr RPAREN LBRACKET stmt_list RBRACKET false_branch 
    { If($3, List.rev $6, $8) }

opt_init:
  { None }
| ASSIGN expr { Some($2) }

expr_opt:
  { Noexpr }
  | expr { $1 }

false_branch: elif { $1 } | cf_else { $1 } | %prec NOELSE { [] }

elif:
ELIF LPAREN expr RPAREN LBRACKET stmt_list RBRACKET false_branch 
    { [If($3, List.rev $6, $8)] }

cf_else:
ELSE LBRACKET stmt_list RBRACKET { List.rev $3 }

expr:
| expr INCREMENT { Assign($1, Binop($1, Add, IntLit(1))) }
| expr DECREMENT { Assign($1, Binop($1, Sub, IntLit(1))) }
| expr ASSIGN expr { Assign($1, $3) }
| expr PLUS expr { Binop($1, Add, $3) }
| expr MINUS expr { Binop($1, Sub, $3) }
| expr TIMES expr { Binop($1, Mult, $3) }
| expr DIVIDE expr { Binop($1, Div, $3) }
| expr MOD expr { Binop($1, Mod, $3) }
| expr EQ expr { Binop($1, Equal, $3) }
| expr NEQ expr { Binop($1, Neq, $3) }
| expr LT expr { Binop($1, Less, $3) }
| expr LEQ expr { Binop($1, Leq, $3) }
| expr GT expr { Binop($1, Greater, $3) }
| expr GEQ expr { Binop($1, Geq, $3) }
| expr AND expr { Binop($1, And, $3) }
| expr OR expr { Binop($1, Or, $3) }
| MINUS expr %prec NEG { Unop(Neg, $2) }
| NOT expr { Unop(Not, $2) }
| NEW LPAREN newable RPAREN { New($3) }
| function_expr { FExpr($1) }
| LBRACKET init_list RBRACKET { StructInit(List.rev $2) }
| LSQBRACE opt_items RSQBRACE { ArrayLit($2) }
| accessor { $1 }
| LPAREN expr RPAREN { $2 }

accessor:
  accessor LPAREN args_opt RPAREN { FCall($1, $3) }
| accessor LSQBRACE expr RSQBRACE { ArrayAccess($1, $3) }
| accessor DOT ID { Dot($1, $3) }
| atom { $1 }

atom:
  INTLIT { IntLit($1) }
| FLOATLIT { FloatLit($1) }
| BOOLLIT { BoolLit($1) }
| STRLIT { StrLit($1) }
| ID { Id($1) }

newable:
  ARRAY LT typ GT LSQBRACE expr RSQBRACE { NArray($3, $6) }
| STRUCTID { NStruct($1) }

function_expr:
    FUNCTION LPAREN params_opt RPAREN ret_typ LBRACKET stmt_list 
    RBRACKET
    { { name = "";
        params = $3;
        typ = $5;
        body = List.rev $7} }

opt_items:
  { [] }
| item_list { List.rev $1 }

item_list:
  expr { [$1] }
| item_list COMMA expr { $3 :: $1 }

opt_loop_init:
  { None }
| expr { Some(Expr($1)) }
| typ ID ASSIGN expr { Some(VDecl($1, $2, Some($4))) }

opt_expr:
  { None }
| expr { Some($1) }

ret_typ:
  VOID { Void }
| typ { $1 }

typ:
  INT { Int }
| FLOAT { Float }
| BOOL { Bool }
| STRING { String }
| ARRAY LT typ GT { Array($3) }
| func_type { Func($1) }
| STRUCTID { Struct({ struct_name = $1; 
    members = StringMap.empty; incomplete = true }) }

/* This is the type for Func with the syntax
func(parameter_type1, parameter_type2; return_type) */
func_type:
    FUNC LPAREN typ_opt SEMI ret_typ RPAREN
    { { param_typs = $3;
        return_typ = $5 } }

typ_opt:
  { [] }
| typ_list { List.rev $1 }

typ_list:
  typ { [$1] }
| typ_list COMMA typ { $3 :: $1 }

params_opt:
  { [] }
| param_list { List.rev $1 }

param_list:
  typ ID { [($1, $2)] }
| param_list COMMA typ ID { ($3, $4) :: $1 }

args_opt:
  { [] }
| arg_list { List.rev $1 }

arg_list:
  expr { [$1] }
| arg_list COMMA expr { $3 :: $1 }

destruct:
  dest_mem SEMI { [$1] }
| destruct dest_mem SEMI { $2 :: $1 }

dest_mem:
  ID { Expr(Id($1)) }
| ID COLON LBRACKET destruct RBRACKET { Destruct(List.rev $4, Id($1), "") }

mems_opt:
  { [] }
| mem_list { List.rev $1 }

mem_list:
  member SEMI { [$1] }
| mem_list member SEMI { $2 :: $1 }

member:
  typ ID { ($1, $2, None) }
| typ ID ASSIGN expr { ($1, $2, Some($4)) }

init_list:
  init SEMI { [$1] }
| init_list init SEMI { $2 :: $1 }

init: ID ASSIGN expr { ($1, $3) }
\\end{lstlisting}
\\end{mdframed}
\\subsection*{sast.ml}
\\begin{mdframed}[hidealllines=true,backgroundcolor=blue!20]
\\begin{lstlisting}
open Ast

type styp =
    SVoid
  | SInt
  | SFloat
  | SBool
  | SString
  | SFunc of sfunc_typ
  | SStruct of sstruct_typ
  | SArray of styp
  | SABSTRACT
  | SAny

and sfunc_typ = {
  sparam_typs: styp list;
  sreturn_typ: styp;
  sbuiltin: bool;
}

and sstruct_typ = {
  sstruct_name: string;
  smembers: (styp * sexpr option) StringMap.t;
  sincomplete: bool;
  signore: bool;
}

and snewable =
    SNArray of styp * sexpr
  | SNStruct of styp

and sexpr = styp * sx
and sx =
    SIntLit of int
  | SFloatLit of string
  | SStrLit of string
  | SBoolLit of bool
  | SArrayLit of sexpr list
  | SId of string
  | SBinop of sexpr * op * sexpr
  | SUnop of uop * sexpr
  | SPop of sexpr * pop 
  | SAssign of sexpr * sexpr
  | SFCall of sexpr * sexpr list
  | SFExpr of sfexpr
  | SStructInit of styp * (string * sexpr) list
  | SArrayAccess of sexpr * sexpr
  | SDot of sexpr * string
  | SNew of snewable
  | SClosure of sclsr
  | SNoexpr
and sbind = styp * string

and sfexpr = {
  sname : string;
  srecursive : bool; 
  styp : styp;
  sparams: sbind list;
  sbody : sstmt list
}

and sclsr = {
  ind: int;
  free_vars: sbind list;
}

and sstmt =
    SExpr of sexpr
  | SVBlock of sstmt list
  | SVDecl of styp * string * sexpr option
  | SReturn of sexpr
  | SIf of sexpr * sstmt list * sstmt list
  | SForLoop of (sstmt option) * (sexpr option) * (sexpr option) * sstmt list
  | SStructDef of string * (styp * string * sexpr option) list

type sprogram = sstmt list

let string_of_sstmt = function
  | SExpr(_) -> "SExpr"
  | _ -> "Other"

(* PRETTY PRINTING based off of printer.ml *)
let rec fmt_styp = function
    SVoid -> "svoid"
  | SFunc(e) -> "sfunc(" ^ 
                (String.concat "," (List.map fmt_styp e.sparam_typs)) ^ "; " 
                ^ (fmt_styp e.sreturn_typ) ^ ")" 
  | SInt -> "sint"
  | SFloat -> "sfloat"
  | SBool -> "sbool"
  | SString -> "sstring"
  | SStruct(st) -> fmt_four "sstruct" st.sstruct_name 
                     (fmt_list (List.map (fun (k, _) -> k) 
                     (StringMap.bindings st.smembers))) 
                     (string_of_bool st.sincomplete)
                     (string_of_bool st.signore)
  | SArray(t) -> fmt_one "sarray" (fmt_styp t)
  | SABSTRACT -> "SABSTRACT"
  | SAny -> "SAny"

let fmt_sparams l =
  let fmt_p = function
      (t, n) -> String.concat "" ["("; fmt_styp t; ", "; n; ")"] in
  fmt_list (List.map fmt_p l)

let rec fmt_sexpr (_,s) =
  (match s with
     SIntLit(l) -> fmt_one "IntLit" (string_of_int l)
   | SFloatLit(l) -> fmt_one "FloatLit" l
   | SStrLit(l) -> fmt_one "StrLit"  l
   | SBoolLit(l) -> fmt_one "BoolLit" (string_of_bool l)
   | SId(s) -> fmt_one "Id" s
   | SBinop(e1, o, e2) -> (fmt_sexpr e1) ^ "\n    " ^ (fmt_op o) ^ "\n    " 
                          ^ (fmt_sexpr e2)
   | SUnop(uo, e) -> fmt_two "Unop" (fmt_uop uo) (fmt_sexpr e)
   | SPop(e, po) -> fmt_two "Pop" (fmt_sexpr e) (fmt_pop po)
   | SAssign(e1, e2) -> fmt_two "Assign" (fmt_sexpr e1) (fmt_sexpr e2)
   | SArrayAccess(s, e) -> fmt_two "ArrayAccess" (fmt_sexpr s) (fmt_sexpr e)
   | SDot(e, s) -> fmt_two "Dot" (fmt_sexpr e) s
   | SFCall(se, a) -> "SFCall(\n      " ^ ((fmt_sexpr se) ^ "\n") ^ ("      " 
                                ^ fmt_list (List.map fmt_sexpr a) ^ "\n    )")
   (* below actually is parsed with {name = e.name; param = e.params;
    * typ = e.typ; body = e.body}. See test programs for examples. *)
   | SFExpr(s) -> fmt_three "FExpr" (fmt_sparams s.sparams)
                    (fmt_styp s.styp) (fmt_sstmt_list s.sbody)
   | SStructInit(_, l) -> fmt_one "StructInit" (fmt_sinit l)
   | SArrayLit(l) -> fmt_one "ArrayLit" (fmt_list (List.map fmt_sexpr l))
   | SNew(t) -> fmt_one "New" (fmt_sn t)
   | SClosure(clsr) -> fmt_two "Closure" (string_of_int clsr.ind) 
                         (fmt_list (List.map (fun (t, n) -> fmt_styp t ^ " " ^ n) 
                            clsr.free_vars))
   | SNoexpr -> ""
  )

and fmt_sn = function
    SNArray(t, s) -> fmt_two "NArray" (fmt_styp t) (fmt_sexpr s)
  | SNStruct(n) -> fmt_one "NStruct" (fmt_styp n)

and fmt_smembers l =
  let fmt_m = function
      (t, n, None) -> fmt_three "" (fmt_styp t) n "None"
    | (t, n, Some(e)) -> fmt_three "" (fmt_styp t) n (fmt_sexpr e) in
  fmt_list (List.map fmt_m l)

and fmt_sinit l =
  let fmt_i (n, e) = fmt_two "" n (fmt_sexpr e) in
  fmt_list (List.map fmt_i l)

and fmt_sstmt = function
    SExpr(se) -> fmt_sexpr se
  | SReturn(e) -> "Return " ^ (fmt_sexpr e)
  | SVDecl (t, n, l) -> (fmt_styp t) ^ " " ^ n ^ " = " ^ (match l with 
        None -> "" | Some(e) -> fmt_sexpr e)
  | SForLoop (init, e2, e3, s) -> 
    fmt_four "ForLoop" 
      (match init with None -> "" | Some(s) -> fmt_sstmt s)
      (fmt_opt_sexpr e2) 
      (fmt_opt_sexpr e3) (fmt_sstmt_list s)
  | SStructDef(n, m) -> fmt_two "StructDef" n (fmt_smembers m)
  | SIf(e, tL, fL) -> fmt_three "If" (fmt_sexpr e) (fmt_sstmt_list tL) 
                        (fmt_sstmt_list fL)
  | SVBlock(_) -> "SVBlock"

and fmt_sstmt_list ?spacer l =
  let sstmts = List.map fmt_sstmt l in
  let s = match spacer with Some(s) -> s | _ -> "" in
  let sstmts = List.map (fun x -> s ^ x) sstmts in
  String.concat "\n" sstmts

and fmt_opt_sexpr = function
    None -> ""
  | Some(e) -> fmt_sexpr e

let string_of_sprogram sast =
  String.concat ";\n" (List.map fmt_sstmt sast)
\\end{lstlisting}
\\end{mdframed}
\\subsection*{semant.ml}
\\begin{mdframed}[hidealllines=true,backgroundcolor=blue!20]
\\begin{lstlisting}
open Ast
open Sast

module StringMap = Map.Make (String)

exception Type_mismatch of string
exception Undeclared_reference of string

let builtinsFunc = [
  ("println", Func({ param_typs = [String]; return_typ = Void }));
  ("print", Func({ param_typs = [String]; return_typ = Void }));
  ("str_of_int", Func({ param_typs = [Int]; return_typ = String }));
  ("str_of_bool", Func({ param_typs = [Bool]; return_typ = String }));
  ("string_concat", Func({ param_typs = [String; String]; return_typ = String })); 
  ("string_equals", Func({ param_typs = [String; String]; return_typ = Int })); 
  ("str_of_float", Func({ param_typs = [Float]; return_typ = String })); 
  ("int_of_float", Func({ param_typs = [Float]; return_typ = Int })); 
  ("float_of_int", Func({ param_typs = [Int]; return_typ = Float })); 
  ("scan_line", Func({ param_typs = [Int]; return_typ = String })); 
  ("exit_success", Func({ param_typs = []; return_typ = Void })); 
  ("die", Func({ param_typs = [String; Int]; return_typ = Void })); 
  ("int_of_str", Func({ param_typs = [String]; return_typ = Int })); 
  ("rand_autoseed", Func({ param_typs = []; return_typ = Void }));  
  ("rand_afterseed", Func({ param_typs = []; return_typ = Int }));
  ("scan_char", Func({ param_typs = []; return_typ = String }));
]

let makeMapFromBuiltinsFunc map arrElem = 
  StringMap.add (fst arrElem) (snd arrElem) map

let builtinMap = List.fold_left 
  makeMapFromBuiltinsFunc StringMap.empty builtinsFunc

let check_assign lvaluet rvaluet err =
  if lvaluet = rvaluet then lvaluet else raise err

let rec compare_typs t1 t2 = match t1, t2 with
    SStruct(s_l), SStruct(s_r) -> s_l.sstruct_name = s_r.sstruct_name
  | SArray(SAny), SArray(_) -> true
  | SArray(_), SArray(SAny) -> true
  | SFunc(f1), SFunc(f2) ->
    let same_ret = compare_typs f1.sreturn_typ f2.sreturn_typ in
    let same_args = List.for_all2 compare_typs f1.sparam_typs f2.sparam_typs
    in same_ret && same_args
  | _ -> t1 = t2

let check_asn lvalue_t rvalue_t =
  let found_match = compare_typs lvalue_t rvalue_t in
  if found_match
  then lvalue_t
  else
    (print_endline(Printexc.raw_backtrace_to_string(Printexc.get_callstack 100));
     raise (Type_mismatch ("type mismatch error " ^ 
        fmt_styp lvalue_t ^ " " ^ fmt_styp rvalue_t)))

(* This function takes a tuple with the type and the map 
 * as well as the variable name and the context map.
 * The map in the tuple is used for the member fields
 * in structs. The map is None unless you are adding a new
 * struct type. *)    
let add_to_ctxt (v_type : styp) (v_name : string) 
    (ctxt : styp StringMap.t list) =
  let map = List.hd ctxt in
  try
    match (StringMap.find v_name map) with
      _ -> raise (Failure (v_name ^ " already declared"))
  with Not_found ->
    let newMap = StringMap.add v_name v_type map in
    newMap::List.tl ctxt

(* Returns a tuple with the type and the map and if
 * the variable is initalized or not. The type and
 * map are optional. *)
let rec find_in_ctxt (v_name : string) (ctxt : styp StringMap.t list) =
  try
    StringMap.find v_name (List.hd ctxt)
  with Not_found -> match List.tl ctxt with
      [] -> raise (Undeclared_reference ("undeclared reference " ^ v_name))
    | tail -> find_in_ctxt v_name tail


let context_to_bindings (ctxt : styp StringMap.t list) =
  let combine_scopes s1 s2 = StringMap.union (fun _ v1 _ -> Some(v1)) s1 s2 in
  let map = List.fold_left combine_scopes StringMap.empty ctxt in
  StringMap.bindings map

let rec ignore_structs t = match t with
    SStruct(st) ->
    SStruct({
        sstruct_name = st.sstruct_name;
        smembers = st.smembers;
        sincomplete = st.sincomplete;
        signore = true;
      })
  | SArray(t) -> SArray(ignore_structs t)
  | SFunc(f) -> SFunc({
      sparam_typs = List.map ignore_structs f.sparam_typs;
      sreturn_typ = ignore_structs f.sreturn_typ;
      sbuiltin = f.sbuiltin;
    })
| _ -> t

(* Returns a tuple with a map and another tuple.
 * The second tuple has the type and the stype. *)
let rec check_expr (ctxt : styp StringMap.t list) = function
  | IntLit(x) -> (SInt, SIntLit x)
  | BoolLit(x) -> (SBool, SBoolLit x)
  | FloatLit(x) -> (SFloat, SFloatLit x)
  | StrLit(x) -> (SString, SStrLit x)

  | New(NStruct(name)) ->
    let t = find_in_ctxt name ctxt in
    (t, SNew(SNStruct(t)))
  | New(NArray(t,e)) ->
    let (t_e, se_e) = check_expr ctxt e 
    in
    if t_e <> SInt then raise (Failure ("array size must be an integer type"))
    else let st = ignore_structs(styp_of_typ ctxt t) in (SArray (st), 
                                        SNew(SNArray(st, (t_e, se_e))))
  | StructInit(assigns) -> 
    let (struct_t, assigns') = 
      let assigns' = List.map (fun (n, e) -> let se = check_expr ctxt e 
                                in (n, se)) assigns in
      let compare = function
          SStruct(st) when not st.signore ->
          let mems = List.map (fun (n, (t, _)) -> (n, t)) 
              (StringMap.bindings st.smembers) in
          let compare_by (n1, _) (n2, _) = compare n1 n2 in
          let mems = List.sort compare_by mems in
          let assigns' = List.sort compare_by assigns' in
          if List.length mems <> List.length assigns' then false
          else List.for_all2 (fun (n1, t1) (n2, (t2, _)) 
                               -> (compare_typs t1 t2) && n1 = n2) mems assigns'
        | _ -> false
      in
      let binds = context_to_bindings ctxt in
      let types = List.map (fun (_, v) -> v) binds in
      let struct_ts = List.filter compare types in
      match struct_ts with
        [] -> raise (Failure "invalid struct initialization")
      | hd::[] -> (hd, assigns')
      | _ -> raise (Failure "shouldn't happen")
    in
    (struct_t, SStructInit(struct_t, assigns'))

  (* Go through all the items in the square brackets to see if they match *)
  (* check_expr never changes the map so we shouldn't pass
   * it around all the time. *) 
  | ArrayLit(x) -> 
    if List.length x = 0
    then raise (Failure "empty array init is not supported")
    else 
      let (item_type, _) = check_expr ctxt (List.hd x) in
      let item_type = ignore_structs item_type in 
        (* recursively do this everywhere *)
      let t = List.map (fun e1 ->
          let (t1, st1) = check_expr ctxt e1 in
          let t1 = ignore_structs t1 in
          if (t1 = item_type) then (t1, st1)
          else raise (Failure("Error: cannot have multiple types in an array ("
                              ^ fmt_styp t1 ^ " and " ^ fmt_styp item_type ))
        ) x in (SArray(item_type), SArrayLit t)
  
  | ArrayAccess(expr, int_expr) ->
    let (t1, se1) = check_expr ctxt expr in
    let (t2, se2) = check_expr ctxt int_expr in
    let t3 = match t1 with 
        SArray(t) -> t 
      | _ -> raise (Failure ("not an array"))
    in
    if t2 = SInt then (t3, SArrayAccess((t1, se1), (t2, se2)))
    else raise (Failure ("can't access array with non-integer type"))

  | Id(n) -> 
    let t = find_in_ctxt (if String.contains n '~' then String.sub n 1 
        ((String.length n) - 1) else n) ctxt in
    if (String.contains n '~') then 
        (t, SId (String.sub n 1 ((String.length n) - 1)))
    else (match t with
      SFunc(f) when f.sbuiltin -> 
        let ft = match StringMap.find n builtinMap with 
            Func(func) -> func | _ -> raise (Failure ("shouldn't happen")) in
      check_expr ctxt (FExpr({
      name = "";
      typ = ft.return_typ;
      params = List.mapi (fun i t -> (t, "__p" ^ (string_of_int i))) ft.param_typs;
      body = if ft.return_typ == Void then [
        Expr(FCall(Id("~" ^ n), List.mapi (fun i _ -> Id("__p" ^ 
            (string_of_int i))) ft.param_typs))
      ] else [
        VDecl(ft.return_typ, "__ret", Some(FCall(Id("~" ^ n), 
            List.mapi (fun i _ -> Id("__p" ^ (string_of_int i))) ft.param_typs)));
        Return(Id("__ret"))
      ];}))
    | _ -> (t, SId n))

  | Assign(e1, e2) ->
    let (t1, se1) = match e1 with
        Id(n) -> let t = find_in_ctxt n ctxt in
        (t, SId n)
      | _ -> check_expr ctxt e1 
    in
    let (t2, se2) = check_expr ctxt e2 in
    (check_asn t1 t2, SAssign((t1, se1), (t2, se2)))

  | Dot(e, field_name) -> 
    let check_struct_access struct_type field_name = 
      let ((access_type, _), st) = (match struct_type with
          (* make sure you were passed a struct *)
            SStruct(s) ->
            (let t = find_in_ctxt s.sstruct_name ctxt in 
             (* Get the complete struct with members *)
             let struct_t = match t with 
                 SStruct(st) -> st 
               | _ -> raise (Failure "not a struct")
             in
             try (StringMap.find field_name struct_t.smembers, SStruct(struct_t))
             with Not_found -> 
               raise (Failure 
                        ("struct " ^ s.sstruct_name ^ 
                            " has no member " ^ field_name)))
          | _ -> print_endline(fmt_styp struct_type); 
            raise (Failure "dot operator used on non-struct type"))
      in (access_type, st)
    in
    let (t1, se1) = check_expr ctxt e in
    let (field_type, _ ) = check_struct_access t1 field_name 
    in (field_type, SDot((t1, se1), field_name))

  | Binop(e1, op, e2) ->
    let (lt, se1) = check_expr ctxt e1 in
    let (rt, se2) = check_expr ctxt e2 in
    let sbinop = SBinop((lt, se1), op, (rt, se2)) in
    (match op with
       Add | Sub | Mult | Div | Mod when lt = SInt && rt = SInt 
       -> (SInt, sbinop)
     | Add | Sub | Mult | Div when lt = SFloat && rt = SFloat 
       -> (SFloat, sbinop)
     | Add when lt = SString && rt = SString -> (SString,sbinop)
     | Equal | Neq  when lt = rt -> (SBool, sbinop)
     | Less | Leq | Greater | Geq  
       when (lt = SInt && rt = SInt) 
         || (lt = SFloat || rt = SFloat) -> 
       (SBool, sbinop)
     | And | Or when lt = SBool && rt = SBool -> (SBool, sbinop)
     | _ -> raise (Failure("Error: cannot use " ^ fmt_op op ^ 
                           " with types: "^ fmt_styp rt ^ " and " ^ fmt_styp lt )))

  | Unop(op, e) -> 
    let (t, e) = check_expr ctxt e in 
    let sunop = SUnop(op, (t, e)) in
    (match op with 
       Neg when t = SInt -> (SInt, sunop)
     | Neg when t = SFloat -> (SFloat, sunop)
     | Not when t = SBool -> (SBool, sunop)
     | _ -> raise (Type_mismatch "Type mismatch for unary operator"))

  | FCall(expr, args) ->
    let check_args f_type args =
      let rec helper sl = function
          ([], []) -> sl
        | (p_typ::pl, arg::al) ->
          let (a_typ, se) = check_expr ctxt arg in
          if compare_typs p_typ (ignore_structs a_typ) 
            then helper ((a_typ, se)::sl) (pl, al)
          else raise (Failure "argument type mismatch")
        | _ -> raise (Failure "invalid number of arguments")
      in
      helper [] (f_type.sparam_typs, args)
    in
    let (t, se) = match expr with
      Id(s) when not (String.contains s '~') -> (find_in_ctxt s ctxt, SId(s))
    | _ -> check_expr ctxt expr 
    in
    let (func_t, sl) = match t with
        SFunc(func_t) -> (func_t, check_args func_t args)
      | _ -> raise (Failure "not a function")
    in
    (func_t.sreturn_typ, SFCall((t, se), sl))

  | FExpr(fexpr) ->
    let conv_params (typ, _ ) = (ignore_structs (styp_of_typ ctxt typ)) in
    let conv_params_with_both_fields (typ, str) = 
      (ignore_structs (styp_of_typ ctxt typ),str) in
    let sfunc_t = SFunc({
      sreturn_typ = ignore_structs (styp_of_typ ctxt fexpr.typ);
      sparam_typs = List.map conv_params fexpr.params;
      sbuiltin = false;
    }) in
    let create_scope list =
      let rec helper m = function
          [] -> m
        | (t, n)::tl -> 
          let new_m = StringMap.add n (styp_of_typ ctxt t) m in 
          helper new_m tl
      in
      if fexpr.name <> ""
      then helper (StringMap.add fexpr.name sfunc_t StringMap.empty) list
      else helper StringMap.empty list
    in
    let func_scope = create_scope fexpr.params in
    let (_, return_t, sl) = check_stmt_list (func_scope::ctxt) fexpr.body in
    ignore (check_asn (ignore_structs return_t) 
      (ignore_structs (styp_of_typ ctxt fexpr.typ)));
    (sfunc_t, SFExpr({
         sname = fexpr.name;
         styp = ignore_structs(styp_of_typ ctxt fexpr.typ);
         sparams = List.map conv_params_with_both_fields fexpr.params;
         sbody = sl;
         srecursive = false;
       }))

  | Noexpr -> (SVoid, SNoexpr)
  | _ as x -> print_endline(Ast.fmt_expr x); 
    raise (Failure "not implemented in semant")

and styp_of_typ ctxt = function
    Int -> SInt
  | Bool -> SBool
  | Float -> SFloat
  | String -> SString
  | Void -> SVoid
  | Func f -> SFunc({ sparam_typs = List.map (styp_of_typ ctxt) f.param_typs; 
    sreturn_typ = styp_of_typ ctxt f.return_typ; sbuiltin = false; })
  | Struct s -> find_in_ctxt s.struct_name ctxt
  | Array t -> SArray(styp_of_typ ctxt t) 
  | ABSTRACT -> SABSTRACT

and check_stmt_list (ctxt : styp StringMap.t list) = function
    [] -> (ctxt, SVoid, [])
  | hd::tl -> 
    let (nctxt, t, ss) = check_stmt ctxt hd in
    let (nctxt, t_rest, ssl) = check_stmt_list nctxt tl in
    let ret =
      if t = SVoid
      then t_rest 
      else (if List.length tl <> 0 then raise 
        (Failure "dead code after return") else (); t)
    in
    (nctxt, ret, ss::ssl) (* returned something *)

and check_bool_expr (ctxt : styp StringMap.t list) e = 
  let (t, st) = check_expr ctxt e in
  if (t <> SBool) then 
    raise (Failure("Error: " ^ fmt_styp t ^ " is not a boolean type"))
  else (t, st)

(* returns the map, type, stype *)
and check_stmt (ctxt : styp StringMap.t list) = function
    Expr(e) -> let (t, ss) = 
                 check_expr ctxt e in (ctxt, SVoid, SExpr((t, ss)))
  | Destruct(keys, src, inner) ->
    let (t, se) = check_expr ctxt src in
    let tmp_n = "__tmp" ^ inner in
    let nctxt = add_to_ctxt t tmp_n ctxt in
    let init = SVDecl(t, tmp_n, Some((t, se))) in
    let members = match t with 
        SStruct(struct_t) -> struct_t.smembers
      | _ -> raise (Failure "cannot destruct non-struct")
    in
    let helper = function
        Expr(Id(x)) -> 
        let (ty, _) = StringMap.find x members in
        let v = check_expr nctxt (Dot(Id(tmp_n), x)) in
        (ty, x, SVDecl(ty, x, Some(v)))
      | _ -> raise (Failure "should've been caught in parser")
    in
    let (nctxt, decls) = List.fold_left 
      (fun (ctxt, decls) k -> 
          let (t, n, decl) = helper k in 
          (add_to_ctxt t n ctxt, decl::decls)) 
      (nctxt, [init]) keys in
    (nctxt, SVoid, SVBlock(List.rev decls))
  | VDecl(ltype, n, i) ->
    let t = match ltype with 
        Struct(struct_t) -> find_in_ctxt struct_t.struct_name ctxt 
      | _ -> styp_of_typ ctxt ltype
    in
    let t = ignore_structs t in
    (match i with
       None -> (add_to_ctxt t n ctxt, SVoid, SVDecl(t, n, None))
     | Some(e) ->
       let (t_i, s_i) = check_expr ctxt e in
       let t_i = ignore_structs t_i in
       let nctxt = add_to_ctxt t n ctxt in
       (nctxt, SVoid, SVDecl((check_asn t_i t), n, Some((t_i, s_i)))))

  | StructDef(name, fields) ->
    let conv_typ typ = ignore_structs (styp_of_typ ctxt typ) in
    let helper (map, list) (lt, n, i) =
      let lt = conv_typ lt in
      match lt with
        SStruct(struct_t) when name = struct_t.sstruct_name -> 
            raise (Failure ("illegal recursive struct " ^ name))
      | _ ->
        try
          match (StringMap.find n map) with
            _ -> raise (Failure (n ^ " already declared in struct " ^ name))
        with Not_found ->
          let (init, opt_se) = match i with
              None -> (None, None)
            | Some e ->
              let (rt, se) = check_expr ctxt e in
              let _ = check_asn (lt) rt in
              (Some(rt, se), Some(rt, se))
          in
          let new_map = StringMap.add n (lt, init) map in
          let new_list = (lt, n, opt_se)::list in
          (new_map, new_list)
    in
    let (members, fields_se) = List.fold_left helper 
      (StringMap.empty, []) fields in
    let struct_t = SStruct({
        sstruct_name = name;
        smembers = members;
        sincomplete = false;
        signore = false;
      }) in
    let nctxt = add_to_ctxt struct_t name ctxt in
    (nctxt, SVoid, SStructDef(name, fields_se))

  | Return(e) -> 
    let (t, ss) = check_expr ctxt e in 
    (ctxt, t, SReturn((t, ss)))
  | ForLoop (s1, e2, e3, st) -> 
    let (ctxt1, s1') = match s1 with
        None -> (StringMap.empty::ctxt, None)
      | Some(s1) -> (let (nctxt, _, ns1) = check_stmt (StringMap.empty::ctxt) s1 in
                     (nctxt, Some(ns1)))
    in
    let (ctxt2, e2') = match e2 with
        None -> (ctxt1, None)
      | Some(e2) -> (let (t_i, si) = 
                       check_bool_expr ctxt1 e2 in (ctxt1, Some((t_i, si))))
    in
    let (ctxt3, e3') = match e3 with
        None -> (ctxt2, None)
      | Some(e3) -> (let (t_i, si) = 
                       check_expr ctxt2 e3 in (ctxt2, Some((t_i, si))))
    in
    let (_, ret_t, st') = check_stmt_list ctxt3 st
    in
    (ctxt, ret_t, SForLoop(s1', e2', e3', st'))

  | If (e, st1, st2) ->
    let e' = check_bool_expr ctxt e
    in
    let ifctxt = StringMap.empty::ctxt in
    let (_, rt1, st1') = check_stmt_list ifctxt st1
    in
    let (_, rt2, st2') = check_stmt_list ifctxt st2
    in
    let rt = match rt1, rt2 with
        (SVoid, _) -> SVoid
      | (_, SVoid) -> SVoid
      | (t1, t2) -> check_asn t1 t2
    in
    (ctxt, rt, SIf(e', st1', st2'))

  | _ -> (ctxt, SVoid, SExpr((SVoid, SNoexpr)))

let builtins = [
  ("println", SFunc({ sparam_typs = [SString]; sreturn_typ = SVoid; 
    sbuiltin = true; }));
  ("print", SFunc({ sparam_typs = [SString]; sreturn_typ = SVoid; 
    sbuiltin = true; }));
  ("str_of_int", SFunc({ sparam_typs = [SInt]; sreturn_typ = SString; 
    sbuiltin = true; }));
  ("str_of_bool", SFunc({ sparam_typs = [SBool]; sreturn_typ = SString; 
    sbuiltin = true; }));
  ("string_concat", SFunc({ sparam_typs = [SString; SString]; 
    sreturn_typ = SString; sbuiltin = true; })); 
  ("string_equals", SFunc({ sparam_typs = [SString; SString]; 
    sreturn_typ = SInt; sbuiltin = true; })); 
  ("str_of_float", SFunc({ sparam_typs = [SFloat]; 
    sreturn_typ = SString; sbuiltin = true; })); 
  ("int_of_float", SFunc({ sparam_typs = [SFloat]; 
    sreturn_typ = SInt; sbuiltin = true; })); 
  ("float_of_int", SFunc({ sparam_typs = [SInt]; 
    sreturn_typ = SFloat; sbuiltin = true; })); 
  ("scan_line", SFunc({ sparam_typs = [SInt]; 
    sreturn_typ = SString; sbuiltin = true; })); 
  ("exit_success", SFunc({ sparam_typs = []; 
    sreturn_typ = SVoid; sbuiltin = true; })); 
  ("die", SFunc({ sparam_typs = [SString; SInt]; 
    sreturn_typ = SVoid; sbuiltin = true; })); 
  ("int_of_str", SFunc({ sparam_typs = [SString]; 
    sreturn_typ = SInt; sbuiltin = true; })); 
  ("rand_autoseed", SFunc({ sparam_typs = []; 
    sreturn_typ = SVoid; sbuiltin = true; }));
  ("rand_afterseed", SFunc({ sparam_typs = []; 
    sreturn_typ = SInt; sbuiltin = true; }));  
  ("scan_char", SFunc({ sparam_typs = []; sreturn_typ = SString; 
    sbuiltin = true; }));  
]

let def_ctxt =
  let add_func ctxt (name, func_t) = add_to_ctxt func_t name ctxt in
  List.fold_left add_func [StringMap.empty] builtins

let check_program (prog : stmt list) =
  if List.exists (fun x -> match x with Return(_) -> true | _ -> false) prog
  then raise (Failure "illegal return statement")
  else
    let (_, _, ssl) = check_stmt_list def_ctxt prog in
    List.flatten (List.map 
      (fun s -> match s with SVBlock(sl) -> sl | _ as x -> [x]) ssl)

\\end{lstlisting}
\\end{mdframed}
\\subsection*{lift.ml}
\\begin{mdframed}[hidealllines=true,backgroundcolor=blue!20]
\\begin{lstlisting}
open Sast

module StringMap = Map.Make(String)

type environment = {
  variables: styp StringMap.t;
  parent: environment option;
}

(* Lifted function *)
type lfunc = {
  lname: string;
  lfvs: sbind list; (* Free variables *)
  lreturn_typ: styp;
  lparams: sbind list;
  lbody: sstmt list;
}

(* For inbuilt functions, create empty function types *)
let built_in_decls =
  let empty_func ty = ({ sreturn_typ = ty; sparam_typs = []; sbuiltin = true; }) in
  let add_default map (name, ty) = StringMap.add name (SFunc ty) map in
  let builtins = List.map (fun (name, func_t) -> 
      let is_func = match func_t with 
          SFunc(func_t) -> (name, empty_func func_t.sreturn_typ) 
        | _ -> raise (Failure ("not a built-in function")) in is_func)
      Semant.builtins in
  List.fold_left add_default StringMap.empty builtins

let rec lookup (e : environment) name =
  try
    StringMap.find name e.variables
  with Not_found -> match e.parent with
      Some(parent) -> lookup parent name
    | None ->
      try StringMap.find name built_in_decls
      with Not_found -> raise (Failure ("Lift: undeclared identifier " ^ name))

let add_bind m (t, id) = StringMap.add id t m

let rec dfs_sstmt funcs env sstmt =
  let (funcs', fvs', env', sstmt') =
    match sstmt with
      SStructDef(name, members) ->
      let helper (funcs, fvs, members) (ty, n, sexp_opt) = match sexp_opt with
          None -> (funcs, fvs, (ty, n, None)::members)
        | Some(e) ->
          let (funcs', fvs', e') = dfs_sexpr funcs env e in
          (funcs', fvs@fvs', (ty, n, Some(e'))::members)
      in
      let (funcs', fvs', members') = 
        List.fold_left helper (funcs, [], []) members in
      let new_typ = SStruct({
          sstruct_name = name;
          smembers = List.fold_left 
            (fun m (t, n, e) -> StringMap.add n (t, e) m) StringMap.empty members';
          sincomplete = false;
          signore = false
        }) in
      let env' = {
        variables = StringMap.add name new_typ env.variables;
        parent = env.parent
      } in
      (funcs', fvs', env', SStructDef(name, members'))
    | SVDecl(lt, name, i) ->
      let (new_typ, funcs', fvs', opt_sexpr') = match i with
          None -> (lt, funcs, [], None)
        | Some(sexpr) ->
          let (funcs', fvs', sexpr') = dfs_sexpr funcs env sexpr ~fname:name in
          let (rt, _) = sexpr' in
          let new_typ = match (lt, rt) with
              SFunc(_), SFunc(_) -> lt
            | _ -> lt in
          (new_typ, funcs', fvs', Some(sexpr'))
      in
      let env' = {
        variables = StringMap.add name new_typ env.variables;
        parent = env.parent
      } in
      (funcs', fvs', env', SVDecl(new_typ, name, opt_sexpr'))
    | SReturn e -> 
      let (funcs1, fvs1, e1) = dfs_sexpr funcs env e in
      (funcs1, fvs1, env, SReturn(e1))
    | SIf(e, s1, s2) ->
      let (funcs1, fvs1, e') = dfs_sexpr funcs env e in
      let (funcs2, fvs2, _, s1') = dfs_sstmts funcs1 env s1 in
      let (funcs3, fvs3, _, s2') = dfs_sstmts funcs2 env s2 in
      (funcs3, List.concat [fvs1; fvs2; fvs3], env, SIf(e', s1', s2'))
    | SExpr e ->
      let (funcs1, fvs1, e1) = dfs_sexpr funcs env e in
      (funcs1, fvs1, env, SExpr(e1))
    | SForLoop (s1, e1, e2, body) ->
      let (funcs1, fvs1, env', s1') = match s1 with 
          Some(s1) -> (let (funcs1', fvs1', env'', s1'') = 
                         dfs_sstmt funcs env s1 in 
                       (funcs1', fvs1', env'', Some(s1'')))
        | None -> (funcs, [], env, None) 
      in
      let (funcs2, fvs2, e1') = match e1 with
          Some(e1) -> (let (funcs2', fvs2', e1'') = 
                         dfs_sexpr funcs1 env' e1 in (funcs2',fvs2', Some(e1'')))
        | None -> (funcs1, [], None)
      in
      let (funcs3, fvs3, e2') = match e2 with
          Some(e2) -> (let (funcs3', fvs3', e2'') = 
                         dfs_sexpr funcs2 env' e2 in (funcs3', fvs3', Some(e2'')))
        | None -> (funcs2, [], None)
      in
      let (funcs4, fvs4, env_body, body') = 
        List.fold_left 
          (fun (funcs_curr, fvslist, env_curr, stmtlist) s ->
             let (funcs_lift, fvs_lift, env_lift, slift) =
               dfs_sstmt funcs_curr env_curr s in 
             (funcs_lift, fvs_lift::fvslist, env_lift, slift::stmtlist)
          ) (funcs3, [fvs3; fvs2; fvs1], env', []) body in
      (funcs4, List.concat (List.rev fvs4), env_body, 
       SForLoop(s1', e1', e2', body'))   
    | _ -> print_endline(fmt_sstmt sstmt); 
      raise (Failure "not implemented in lifter") in
  let check_scope (_, fv) = not (StringMap.mem fv env.variables) in
  let fvs' = List.filter check_scope fvs' in
  (funcs', fvs', env', sstmt')

and dfs_sstmts funcs env = function
    [] -> (funcs, [], env, [])
  | sstmt :: rest ->
    let (funcs1, fvs1, env1, sstmts1) = 
      dfs_sstmt funcs env sstmt in
    let new_env = {
      variables = List.fold_left add_bind env1.variables fvs1;
      parent = env1.parent
    } in
    let (funcs2, fvs2, env2, sstmts2) = dfs_sstmts funcs1 new_env rest in
    (funcs2, List.concat [fvs1; fvs2], env2, sstmts1::sstmts2)

and dfs_sexpr ?fname funcs env (t, expr) =
  let check_scope (_, fv) = not (StringMap.mem fv env.variables) in
  let (funcs', fvs', expr') = match expr with
      SFExpr(fexpr) ->
      let (funcs', fvs', (t, clsr)) = match fname with
          Some x -> build_closure funcs env fexpr ~fname:x
        | None -> build_closure funcs env fexpr in
      let fvs' = List.filter check_scope fvs' in
      (funcs', fvs', (t, SClosure(clsr)))
    | SNew(SNStruct(SStruct(struct_t))) ->
      let sstruct = lookup env struct_t.sstruct_name in
      (funcs, [], (sstruct, SNew(SNStruct(sstruct))))
    | SStructInit(ty, assigns) ->
      let helper (funcs, fvs, assigns) (n, se) =
        let (funcs', fvs', se') = dfs_sexpr funcs env se in
        (funcs', fvs@fvs', (n, se')::assigns)
      in
      let (funcs', fvs', assigns') = 
        List.fold_left helper (funcs, [], []) assigns in
      (funcs', fvs', (t, SStructInit(ty, assigns')))
    | SDot(se1, field_name) ->
      let (funcs', fvs', expr') = dfs_sexpr funcs env se1 in
      (funcs', fvs', (t, SDot(expr', field_name))) 
    | SArrayLit(sexpr_list) ->
      let helper (funcs, fvs, sexpr_list) se =
        let (funcs', fvs', se') = dfs_sexpr funcs env se in
        (funcs', fvs@fvs', se'::sexpr_list)
      in
      let (funcs', fvs', sexpr_list') = 
        List.fold_left helper (funcs, [], []) sexpr_list in
      (funcs', fvs', (t, SArrayLit(List.rev sexpr_list')))
    | SArrayAccess(expr, int_expr) ->
      let (funcs', fvs2, expr') = dfs_sexpr funcs env expr in
      let (funcs', fvs1, int_expr') = dfs_sexpr funcs' env int_expr in
      (funcs', List.concat [fvs2; fvs1], (t, SArrayAccess(expr', int_expr')))
    | SNew(SNArray(st, expr)) ->
      let (funcs', fvs1, expr') = dfs_sexpr funcs env expr in
      (funcs', fvs1, (t, SNew(SNArray(st, expr'))))
    | SAssign(e1, e2) ->
      let (funcs', fvs2, e2') = dfs_sexpr funcs env e2 in
      let (funcs', fvs1, e1') = dfs_sexpr funcs' env e1 in
      (funcs', List.concat [fvs2; fvs1], (t, SAssign(e1', e2')))
    | SId s1 ->
      let fv =
        if StringMap.mem s1 env.variables || StringMap.mem s1 built_in_decls
        then []
        else [lookup env s1, s1]
      in
      (funcs, fv, (t, SId(s1)))
    | SBinop(se1, op, se2) ->
      let (funcs1, fvs1, se1') = dfs_sexpr funcs env se1 in
      let (funcs2, fvs2, se2') = dfs_sexpr funcs1 env se2 in
      (funcs2, List.concat [fvs1; fvs2], (t, SBinop(se1', op, se2')))
    | SUnop(op, e1) ->
      let (funcs1, fvs1, e1') = dfs_sexpr funcs env e1 in
      (funcs1, fvs1, (t, SUnop(op, e1')))
    | SFCall((lt, se), args) ->
      (match se with
         SId(s1) ->
         let fv' = 
           if StringMap.mem s1 env.variables || StringMap.mem s1 built_in_decls
           then None
           else Some(lookup env s1, s1)
         in
         let (funcs1, fvs1, args') = dfs_sexprs funcs env (List.rev args) in
         let fvs' = match fv' with
             Some(x) -> x :: fvs1
           | _ -> fvs1
         in (funcs1, fvs', (t, SFCall((lt, se), args')))
       | _ ->
         (* Need this for recursion. *)
         let (funcs1, fvs1, _) 
           = dfs_sexpr funcs env (lt, se) in
         let (funcs2, fvs2, args') = dfs_sexprs funcs1 env args in
         (funcs2, fvs1@fvs2, (t, SFCall((lt, se), args'))))
    | _ as x -> (funcs, [], (t, x))
  in
  let fvs' = List.filter check_scope fvs' in
  (funcs', fvs', expr')

and dfs_sexprs funcs env = function
    [] -> (funcs, [], [])
  | sexpr :: rest ->
    let (funcs1, fvs1, sexpr1) = dfs_sexpr funcs env sexpr in
    let new_env = {
      variables = List.fold_left add_bind env.variables fvs1;
      parent = env.parent;
    } in
    let (funcs2, fvs2, rest) = dfs_sexprs funcs1 new_env rest in
    (funcs2, List.concat [fvs1; fvs2], sexpr1 :: rest)

and build_closure ?fname funcs env fexpr =
  let vars = List.fold_left add_bind StringMap.empty fexpr.sparams in
  let name = match fname with Some x -> x | None -> "" in
  let vars_rec = match name with "" -> vars 
    | _ -> StringMap.add name SABSTRACT vars in
  let new_env = {
    variables = vars_rec;
    parent = Some env
  } in
  let (funcs', fvs, _, body') = dfs_sstmts funcs new_env fexpr.sbody in
  let clsr = {
    ind = List.length funcs';
    free_vars = fvs;
  } in
  let new_func = {
    lname = name;
    lfvs = fvs;
    lreturn_typ = fexpr.styp;
    lparams = fexpr.sparams;
    lbody = body'
  } in
  let func_t = {
    sparam_typs = List.map fst fexpr.sparams;
    sreturn_typ = fexpr.styp;
    sbuiltin = false;
  } in
  (new_func :: funcs', fvs, (SFunc(func_t), clsr))

(* Lift takes a list of sast stmts, and converts to a list of (fname, func) *)
(* sstmt list -> (string * lfunc) list *)
let lift sstmts =
  let default_env = { variables = StringMap.empty; parent = None } in
  let (funcs, _, _, sstmts') = dfs_sstmts [] default_env sstmts in
  let main_func = {
    lname = "main";
    lfvs = [];
    lreturn_typ = SInt;
    lparams = [];
    lbody = sstmts'
  } in
  let name i func = ("f" ^ string_of_int i, func) in
  let named_funcs = List.mapi name (List.rev funcs) in
  (("main", main_func) :: named_funcs)

let fmt_lfunc f = String.concat "\n" [
    " -fvs: " ^ String.concat "" 
      (List.map (fun (t, n) -> (fmt_styp t) ^ " " ^ n) f.lfvs);
    " -return_t: " ^ fmt_styp f.lreturn_typ;
    " -params: " ^ String.concat "" 
      (List.map (fun (t, n) -> (fmt_styp t) ^ " " ^ n) f.lparams);
    " -lbody: \n" ^ fmt_sstmt_list f.lbody ~spacer:"    ";
  ]

let helper (name, f) = name ^ ":\n" ^ (fmt_lfunc f)

let rec string_of_lsast = function
    [] -> ""
  | item :: rest -> String.concat "\n" [(helper item);(string_of_lsast rest)]
\\end{lstlisting}
\\end{mdframed}
\\subsection*{codegen.ml}
\\begin{mdframed}[hidealllines=true,backgroundcolor=blue!20]
\\begin{lstlisting}
module L = Llvm

open Ast
open Sast
open Lift

module StringMap = Map.Make(String)

let translate functions =
  let context = L.global_context () in

  let i32_t      = L.i32_type    context
  and i1_t       = L.i1_type     context
  and float_t    = L.double_type context
  and void_t     = L.void_type   context
  and void_ptr_t = L.pointer_type (L.i8_type context)
  and str_t      = L.pointer_type (L.i8_type context)

  and the_module = L.create_module context "Shoo" in

  let rec ltype_of_func name (ret_t : styp) param_ts =
    let param_types = (List.map ltype_of_typ param_ts) in
    let param_types =
      if name = "main" then param_types
      else void_ptr_t :: param_types
    in L.function_type (ltype_of_typ ret_t) (Array.of_list param_types)

  and ltype_of_lfexpr name (lfexpr : lfunc) =
    ltype_of_func name lfexpr.lreturn_typ (List.map fst lfexpr.lparams)

  and ltype_of_sfunction name (sfunc : sfunc_typ) =
    ltype_of_func name sfunc.sreturn_typ sfunc.sparam_typs

  and ltype_of_clsr name lfexpr =
    let func_t = L.pointer_type (ltype_of_lfexpr name lfexpr) in
    L.struct_type context [|func_t; void_ptr_t|]

  and ltype_of_clsr_func name (sfunc : sfunc_typ) =
    let func_t = L.pointer_type (ltype_of_sfunction name sfunc) in
    L.struct_type context [|func_t; void_ptr_t|]

  and ltype_of_typ = function
      SInt -> i32_t
    | SFloat -> float_t
    | SBool -> i1_t
    | SString -> str_t
    | SFunc ftype -> ltype_of_clsr_func "" ftype
    | SVoid -> void_t
    | SStruct(struct_t) ->
      let t_members = List.map 
        (fun (_, (t, _)) -> t) (StringMap.bindings struct_t.smembers) in
      let st = L.struct_type context 
        (Array.of_list (List.map ltype_of_typ t_members)) in
      L.pointer_type st
    | SArray(array_typ) -> L.pointer_type (ltype_of_typ array_typ) 
    | _ -> raise (Failure "not yet implemented")
  in

  let insert_value builder agg i v = L.build_insertvalue agg v i "tmp__" builder in
  let typ_of_lfexpr lfexpr = SFunc({
    sreturn_typ = lfexpr.lreturn_typ;
    sparam_typs = List.map fst lfexpr.lparams;
    sbuiltin = false;
  }) in

  let rec generate_seq n = if n >= 0 then (n :: (generate_seq (n-1))) else [] in
  let builtins : (Sast.styp * L.llvalue) StringMap.t = 
    List.fold_left (fun m (name, ty) -> 
      if name = "length" then m
      else 
        let ftype = match ty with SFunc(f) -> f | _ -> 
          (raise (Failure "shouldn't happen")) in
        let params = List.map ltype_of_typ ftype.sparam_typs in
        let ltype = L.function_type (ltype_of_typ ftype.sreturn_typ) 
          (Array.of_list params) in
        StringMap.add name (ty, (L.declare_function name ltype the_module)) m
    ) StringMap.empty Semant.builtins in

  (* Build each function signature without building the body *)
  let function_decls : (L.llvalue * lfunc) StringMap.t =
    let function_decl m (name, lfexpr) =
      let ftype = ltype_of_lfexpr name lfexpr in
      StringMap.add name (L.define_function name ftype the_module, lfexpr) m 
    in List.fold_left function_decl StringMap.empty functions
  in

  (* Fill in the body for a given function *)
  let build_function_body (name, lfexpr) =
    let (the_function, _) = StringMap.find name function_decls in
    let builder = L.builder_at_end context (L.entry_block the_function) in

    (* Unpacking args and env vars,
       skip for main as its env is empty and has no params *)
    let local_vars =
      let add_param m (t, n) p =
        let () = L.set_value_name n p in
        let local = L.build_malloc (ltype_of_typ t) n builder in
        let _ = L.build_store p local builder in
        StringMap.add n (t, local) m
      in
      let param_list = Array.to_list (L.params the_function) in
      let params =
        if List.length param_list <= 1 then StringMap.empty
        else List.fold_left2 add_param StringMap.empty lfexpr.lparams 
          (List.tl param_list)
      in

      let env =
        if param_list = []
        then L.const_null void_ptr_t
        else List.hd param_list
      in

      let () = L.set_value_name "env" env in
      let env_void_ptr = L.build_malloc void_ptr_t "env" builder in
      let _ = L.build_store env env_void_ptr builder in
      let env_p = L.build_load env_void_ptr "env_p" builder in

      let params_of_lfexpr lfexpr = match lfexpr.lfvs with
          [] -> params
        | _ ->
          let ptr_of_fv (t, _) = L.pointer_type (ltype_of_typ t) in
          let env_struct = L.struct_type context (Array.of_list 
            (List.map ptr_of_fv lfexpr.lfvs)) in
          let env_ptr_t = L.pointer_type env_struct in
          let env_ptr = L.build_bitcast env_p env_ptr_t "env_p" builder in
          let env_val = L.build_load env_ptr "env_val" builder in
          let add_free_var m (t, n) idx =
            let free_var = L.build_extractvalue env_val idx "tmp_" builder in
            StringMap.add n (t, free_var) m
          in
          let fvs_count = List.length lfexpr.lfvs in
          List.fold_left2 add_free_var params lfexpr.lfvs 
            (List.rev (generate_seq (fvs_count - 1)))
      in

      let params_fvs = match name with
          "main" -> params
        | _ -> params_of_lfexpr lfexpr
      in

      (* Allocate a closure of the function within itself for recursive calls *)
      let clsr_t = ltype_of_clsr name lfexpr in
      let clsr_p = L.build_malloc clsr_t lfexpr.lname builder in
      let clsr_val = List.fold_left2 (insert_value builder) 
        (L.const_null clsr_t) [0;1] [the_function;env_p] in
      let _ = L.build_store clsr_val clsr_p builder in
      let func_t  = typ_of_lfexpr lfexpr in
      StringMap.add lfexpr.lname (func_t, clsr_p) params_fvs
    in

    let rec expr builder (m : (styp * L.llvalue) StringMap.t) ((ty, e) : sexpr) =

      let lookup n =
        let (_, llval) = try StringMap.find n m with
            Not_found ->
            if StringMap.mem n builtins then StringMap.find name builtins
            else raise (Failure ("Codegen Variable not found: " ^ n)) 
        in llval
      in

      let build_clsr clsr =
        let fvs = List.map snd clsr.free_vars in
        let llfvs = List.map lookup fvs in
        let fvs_t = List.map ltype_of_typ (List.map fst clsr.free_vars) in
        let fvs_ptr_t = List.map L.pointer_type fvs_t in
        let env_struct_t = L.struct_type context (Array.of_list fvs_ptr_t) in
        let env_struct = L.build_malloc env_struct_t "tmp_" builder in
        let idxs = List.rev (generate_seq ((List.length fvs) - 1)) in
        let env_val = List.fold_left2 (insert_value builder) 
            (L.const_null env_struct_t) idxs llfvs in
        let _ = L.build_store env_val env_struct builder in
        let env_struct_p = L.build_bitcast env_struct void_ptr_t "env_p" builder in

        (* Pack the function ptr and the env ptr into the closure struct *)
        let func_name = "f" ^ (string_of_int clsr.ind) in
        let (llfunc, sfexpr) = StringMap.find func_name function_decls in
        let llclosure_struct_t = ltype_of_clsr func_name sfexpr in
        let clsr_val = List.fold_left2 
            (insert_value builder) 
            (L.const_null llclosure_struct_t)
            [0;1] 
            [llfunc; env_struct_p]
        in clsr_val
      in

      match e with
        SStrLit s -> L.build_global_stringptr s "str" builder
      | SIntLit x -> L.const_int i32_t x
      | SBoolLit b -> L.const_int i1_t (if b then 1 else 0)
      | SFloatLit x -> L.const_float_of_string float_t x
      | SId s -> L.build_load (lookup s) s builder
      | SNoexpr -> L.const_int i32_t 0
      | SAssign((_, SDot((SStruct(struct_t), e), name)), rhs) ->
        let new_v = expr builder m rhs in
        let lhs = expr builder m (SStruct(struct_t), e) in
        let st = L.build_load lhs "structval" builder in
        let compare_by (n1, _) (n2, _) = compare n1 n2 in
        let members = 
          List.sort compare_by (StringMap.bindings struct_t.smembers) in
        let idxs = List.mapi (fun i (n, _) -> (n, i)) members in
        let idx = snd (List.hd (List.filter (fun (n, _) -> n = name) idxs)) in
        let new_struct = L.build_insertvalue st new_v idx name builder in
        ignore(L.build_store new_struct (lhs) builder); new_v
      | SAssign((_, SArrayAccess(arr, i)), e2) ->
        let new_v = expr builder m e2 in
        let arr_var = expr builder m arr in
        let idx = expr builder m i in 
        let ptr = 
          L.build_gep arr_var [| idx |] "" builder 
        in 
        ignore(L.build_store new_v ptr builder); new_v
      | SAssign(e1, e2) ->
        let new_v = expr builder m e2 in
        (match snd e1 with
           SId s -> ignore(L.build_store new_v (lookup s) builder); new_v
         | _ -> raise (Failure ("assignment for " ^ (fmt_sexpr e2) 
           ^ "not implemented in codegen")))
      | SNew(SNArray(array_type, int_expr)) ->
        let array_size = expr builder m int_expr in
        let llarray_t = ltype_of_typ array_type in
        let ptr = L.build_array_malloc llarray_t
            array_size "" builder
        in ptr
      | SNew(SNStruct(SStruct(struct_t))) ->
        let t_members = List.map (fun (_, (t, _)) -> t) 
          (StringMap.bindings struct_t.smembers) in
        let st = L.struct_type context (Array.of_list 
          (List.map ltype_of_typ t_members)) in
        let compare_by (n1, _) (n2, _) = compare n1 n2 in
        let members = List.sort compare_by 
          (StringMap.bindings struct_t.smembers) in
        let llstruct_t = st in
        let vals = List.map (fun (_, (_, opt_e)) -> 
          match opt_e with Some(e) -> Some(expr builder m e) 
                          | None -> None) 
          (List.sort compare_by members) in
        let idxs = List.rev (generate_seq ((List.length members) - 1)) in
        let v = List.fold_left2 (fun agg i opt_v -> 
          match opt_v with Some(v) -> insert_value builder agg i v 
                          | None -> agg) 
          (L.const_null llstruct_t) idxs vals in
        let ptr = L.build_malloc llstruct_t "structlit" builder in
        ignore(L.build_store v ptr builder);
        ptr

      | SArrayLit(sexpr_list) -> 
        if List.length sexpr_list = 0
        then raise (Failure "empty array init is not supported")
        else
          let all_elem = List.map (fun e ->
              expr builder m e) sexpr_list in
          let llarray_t = L.type_of (List.hd all_elem) in
          let num_elems = List.length sexpr_list in
          let ptr = L.build_array_malloc llarray_t
              (L.const_int i32_t num_elems) "" builder 
          in
          ignore (List.fold_left (fun i elem ->
              let idx = L.const_int i32_t i in
              let eptr = L.build_gep ptr [|idx|] "" builder in
              let cptr = L.build_pointercast eptr 
                  (L.pointer_type (L.type_of elem)) "" builder in
              let _ = (L.build_store elem cptr builder) 
              in i+1)
              0 all_elem); ptr

      | SArrayAccess(arr, i) ->
        let arr_var = expr builder m arr in
        let idx = expr builder m i in 
        let ptr = 
          L.build_load (L.build_gep arr_var 
                          [| idx |] "" builder) 
            "" builder 
        in ptr
      | SStructInit(SStruct(struct_t), assigns) ->
        let t_members = List.map (fun (_, (t, _)) -> t) 
          (StringMap.bindings struct_t.smembers) in
        let st = L.struct_type context (Array.of_list 
          (List.map ltype_of_typ t_members)) in

        let compare_by (n1, _) (n2, _) = compare n1 n2 in
        let members = List.sort compare_by 
          (StringMap.bindings struct_t.smembers) in
        let llstruct_t = st in
        let vals = List.map (fun (_, e) -> expr builder m e) 
          (List.sort compare_by assigns) in
        let idxs = List.rev (generate_seq ((List.length members) - 1)) in
        let v = List.fold_left2 (insert_value builder) 
          (L.const_null llstruct_t) idxs vals in
        let ptr = L.build_malloc llstruct_t "structlit" builder in
        ignore(L.build_store v ptr builder);
        ptr

      | SDot((SStruct(struct_t), exp), name) ->
        let lhs = expr builder m (SStruct(struct_t), exp) in
        let s = L.build_load lhs "structval" builder in
        let _
          = ltype_of_typ (SStruct(struct_t)) in
        let compare_by (n1, _) (n2, _) = compare n1 n2 in
        let members = List.sort compare_by 
          (StringMap.bindings struct_t.smembers) in
        let idxs = List.mapi (fun i (n, _) -> (n, i)) members in
        let idx = snd (List.hd (List.filter (fun (n, _) -> n = name) idxs)) in
        L.build_extractvalue s idx name builder
      
      | SBinop (e1, op, e2) -> (*Ref: Justin's codegen.ml*)
        let (t, _) = e1
        and e1' = expr builder m e1
        and e2' = expr builder m e2 in
        (match snd e1, snd e2 with
           _ -> (match t with
               SFloat -> (match op with
                   Add     -> L.build_fadd
                 | Sub     -> L.build_fsub
                 | Mult    -> L.build_fmul
                 | Div     -> L.build_fdiv
                 | Equal   -> L.build_fcmp L.Fcmp.Oeq
                 | Neq     -> L.build_fcmp L.Fcmp.One
                 | Less    -> L.build_fcmp L.Fcmp.Olt
                 | Leq     -> L.build_fcmp L.Fcmp.Ole
                 | Greater -> L.build_fcmp L.Fcmp.Ogt
                 | Geq     -> L.build_fcmp L.Fcmp.Oge
                 | _ ->
                   raise (Failure ("internal error: " 
                     ^ "semant should have rejected and/or on float"))
               ) e1' e2' "tmp" builder
             | SInt -> (match op with
                 | Add     -> L.build_add
                 | Sub     -> L.build_sub
                 | Mult    -> L.build_mul
                 | Div     -> L.build_sdiv
                 | And     -> L.build_and
                 | Or      -> L.build_or
                 | Equal   -> L.build_icmp L.Icmp.Eq
                 | Neq     -> L.build_icmp L.Icmp.Ne
                 | Less    -> L.build_icmp L.Icmp.Slt
                 | Leq     -> L.build_icmp L.Icmp.Sle
                 | Greater -> L.build_icmp L.Icmp.Sgt
                 | Geq     -> L.build_icmp L.Icmp.Sge
                 | Mod     -> L.build_srem
               ) e1' e2' "tmp" builder
             | SBool -> (match op with
                   And     -> L.build_and
                 | Or      -> L.build_or
                 | Equal   -> L.build_icmp L.Icmp.Eq
                 | Neq     -> L.build_icmp L.Icmp.Ne
                 | Less    -> L.build_icmp L.Icmp.Slt
                 | Leq     -> L.build_icmp L.Icmp.Sle
                 | Greater -> L.build_icmp L.Icmp.Sgt
                 | Geq     -> L.build_icmp L.Icmp.Sge
                 | _         -> raise (Failure ("operation " ^ (fmt_op op)
                                                ^ " not implemented for type " 
                                                ^ (fmt_styp t)))
               ) e1' e2' "tmp" builder
             | SString -> (match op with
                   Add -> L.build_call (snd (StringMap.find "string_concat" 
                     builtins)) [| e1'; e2'|] "string_concat" builder
                 | Equal -> (L.build_icmp L.Icmp.Ne) (L.const_int i32_t 0)
                              (L.build_call (snd (StringMap.find 
                                "string_equals" builtins)) [| e1'; e2'|] 
                                "string_equals" builder) "tmp" builder
                 | Neq -> (L.build_icmp L.Icmp.Eq) (L.const_int i32_t 0)
                            (L.build_call (snd (StringMap.find 
                              "string_equals" builtins)) [| e1'; e2'|] 
                              "string_equals" builder) "tmp" builder
                 | _ -> raise (Failure ("operation " ^ (fmt_op op)
                                        ^ " not implemented for type " 
                                        ^ (fmt_styp t))))
             | _ -> (match op with
                   Equal -> (L.build_icmp L.Icmp.Eq) e1' e2' "tmp" builder
                 | Neq -> (L.build_icmp L.Icmp.Ne) e1' e2' "tmp" builder
                 | _ -> raise (Failure ("operation " ^ (fmt_op op)
                                        ^ " not implemented for type " 
                                        ^ (fmt_styp t))))
           ))
      | SUnop(op, e) ->
        let (t, _) = e in
        let e' = expr builder m e in
        (match op with
           Neg when t = SFloat -> L.build_fneg
         | Neg when t = SInt -> L.build_neg
         | Not when t = SBool -> L.build_not
         | _ -> raise (Failure ("operation " ^ (fmt_uop op) ^ 
                                " not implemented for type " 
                                ^ (fmt_styp t)))) e' "tmp" builder
      | SClosure clsr -> build_clsr clsr
      | SFCall((t, SId(name)), args) when StringMap.mem name builtins ->
        (let func_t = match t with
              SFunc(func_t) -> func_t 
            | _ -> raise (Failure "This should never happen")  in
         (match func_t.sreturn_typ with 
            SVoid -> (let arg_array = Array.of_list 
              (List.map (fun arg -> expr builder m arg) args) in
                L.build_call (snd (StringMap.find name builtins)) 
                arg_array "" builder)
          | _ -> (let arg_array = Array.of_list (List.map 
            (fun arg -> expr builder m arg) args) in
              L.build_call (snd (StringMap.find name builtins)) 
              arg_array "_result" builder)))
      | SFCall((t, s), args) ->
        let func_t = match t with
            SFunc(func_t) -> func_t
          | _ -> raise (Failure "wrong type for function call") in
        let clsr_val = expr builder m (t, s) in
        let func_ptr = L.build_extractvalue clsr_val 0 "fp" builder in
        let env_ptr = L.build_extractvalue clsr_val 1 "envp" builder in
        let llargs = env_ptr :: (List.rev (List.map (expr builder m) 
          (List.rev args))) in
        let result = 
            (match func_t.sreturn_typ with SVoid -> "" | _ -> "_result") in
        L.build_call func_ptr (Array.of_list llargs) result builder
      | _ as x -> print_endline(fmt_sexpr (ty, x)); 
        raise (Failure "not implemented in codegen")
    in
    let add_terminal builder instr =
      match L.block_terminator (L.insertion_block builder) with
        None -> ignore (instr builder)
      | Some _ -> ()
    in

    let rec stmt builder m = function
        SExpr e -> let _ = expr builder m e in (builder, m)
      | SStructDef(n, mem) ->
        let struct_t = SStruct({
            sstruct_name = n;
            sincomplete = false;
            signore = false;
            smembers = List.fold_left 
              (fun m (t, n, opt_se) -> StringMap.add n (t, opt_se) m) 
              StringMap.empty mem;
          }) in
        (builder, StringMap.add n (struct_t, L.const_int i1_t 0) m)
      | SVDecl(t, n, se) ->
        let alloc_clsr clsr =
          let func_name = ("f" ^ (string_of_int clsr.ind)) in
          let (_, lfexpr) = StringMap.find func_name function_decls in
          let func_t = L.pointer_type (ltype_of_lfexpr func_name lfexpr) in
          let llclosure_struct_t = L.struct_type context [|func_t; void_ptr_t|] in
          L.build_malloc llclosure_struct_t n builder
        in
        let (builder, local_var) = match se with
            None -> 
            let local_var = L.build_malloc (ltype_of_typ t) n builder in
            (builder, local_var)
          | Some(e) -> 
            let (_, ex) = e in
            let local_var = match ex with
                SClosure(clsr) -> alloc_clsr clsr
              | _ -> L.build_malloc (ltype_of_typ t) n builder
            in
            let e' = expr builder m e in
            let _ = L.build_store e' local_var builder in
            (builder, local_var)
        in
        let m' = StringMap.add n (t, local_var) m in
        (builder, m')
      (* Ref: Justin's codegen.ml *)
      | SIf (pred, then_stmts, else_stmts) ->
        let bool_val = expr builder m pred in
        let merge_bb = L.append_block context "merge" the_function in
        let branch_instr = L.build_br merge_bb in
        let then_bb = L.append_block context "then" the_function in
        let (then_builder, _) = 
          stmt_list (L.builder_at_end context then_bb) m then_stmts in
        let () = add_terminal then_builder branch_instr in
        let else_bb = L.append_block context "else" the_function in
        let (else_builder, _) = 
          stmt_list (L.builder_at_end context else_bb) m else_stmts in
        let () = add_terminal else_builder branch_instr in
        let _ = L.build_cond_br bool_val then_bb else_bb builder in
        (L.builder_at_end context merge_bb, m)
      | SReturn e ->
        let _ = match lfexpr.lreturn_typ with
            SVoid -> L.build_ret_void builder
          | _ -> L.build_ret (expr builder m e) builder
        in (builder, m)
      | SForLoop (init, predicate, incr, body) ->
        (* Build a basic block for the init statement. *)
        let init_bb = L.append_block context "init_loop" the_function in
        let (init_builder, m_incr) = 
          (match init with 
             Some(init) -> 
             stmt (L.builder_at_end context init_bb) m init
           | None -> ((L.builder_at_end context init_bb), m)) 
        in 
        let _ = L.build_br init_bb builder in        

        (* Build a basic block for the condition checking *)
        let pred_bb = L.append_block context "for" the_function in

        (* Branch to the predicate to execute the condition from
         * the current block. *)
        let _ = L.build_br pred_bb init_builder in
        let body_bb = L.append_block context "for_body" the_function
        in

        (* Don't need to keep the map because the variables declared in
         * the for loop only exist in the for loop. *)   
        let (for_builder, _) = List.fold_left (fun (b_bb, temp_map) s -> 
            let (build, map) = 
              stmt b_bb temp_map s in (build, map)) 
            ((L.builder_at_end context body_bb), m_incr) (List.rev body)
        in

        (* Add the increment to the block only if the block doesn't
         * already have a terminator and it has an increment.*)
        let incr_for_builder = match incr with
            Some(incr) ->
            (let has_incr = 
               match L.block_terminator 
                       (L.insertion_block for_builder) with
                 None -> (let (new_incr_builder, _) = 
                            stmt for_builder m_incr (SExpr(incr)) in
                          new_incr_builder)
               | Some _ -> for_builder in has_incr)
          | None -> for_builder in
        let() = add_terminal incr_for_builder (L.build_br pred_bb) in

        (* Generate the predicate code in the predicate block *)
        let pred_builder = L.builder_at_end context pred_bb in
        let bool_val = match predicate with 
            Some(predicate) -> let has_predicate = 
              expr pred_builder m_incr predicate in has_predicate
          | None -> let always_true = 
            expr pred_builder m_incr (SBool, SBoolLit(true)) in always_true
        in

        (* Finish the loop *)
        let merge_bb = L.append_block context "merge" the_function in
        let _ = L.build_cond_br bool_val body_bb merge_bb pred_builder
        in
        (* Return m instead of m_incr because the incr variable doesn't
         * exist outside of the scope of this loop. *)
        (L.builder_at_end context merge_bb, m)

      | _ -> raise (Failure "not implemented in codegen")

    and stmt_list builder m sl =
      let helper (bldr, map) = stmt bldr map in
      let (b, _) = List.fold_left helper (builder, m) sl in
      (b, m)
    in

    let (builder, _) = stmt_list builder local_vars lfexpr.lbody in

    (* add a return if the last block falls off the end *)
    add_terminal builder (match lfexpr.lreturn_typ with
          SVoid -> L.build_ret_void
        | SString -> L.build_ret (L.build_global_stringptr "" "str" builder)
        | SFloat -> L.build_ret (L.const_float_of_string float_t "0.0")
        | t -> L.build_ret (L.const_int (ltype_of_typ t) 0))

  in
  List.iter build_function_body functions;
  the_module
\\end{lstlisting}
\\end{mdframed}
\\subsection*{builtins.c}
\\begin{mdframed}[hidealllines=true,backgroundcolor=blue!20]
\\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <time.h>

#define MAXFLOATSIZE 50

char* str_of_int(int x) {
  int length = snprintf( NULL, 0, "%d", x );
  char* str = malloc( length + 1 );
  snprintf( str, length + 1, "%d", x );
  return str;
}

char* str_of_bool(int x) {
  int length;  
  char* str;
  if (x) {
    str = malloc(sizeof("true") + 1);
    snprintf(str, sizeof("true") + 1, "%s", "true");
  } else {
    str = malloc(sizeof("false") + 1);
    snprintf(str, sizeof("false") + 1, "%s", "false");
  }
  return str;
}

//BUT TECHNICALLY IT"S A C DOUBLE TYPE NOT C FLOAT TYPE
char* str_of_float(double x) {
  char* str;
  str = (char *) malloc( sizeof(char) * MAXFLOATSIZE);
  snprintf(str, MAXFLOATSIZE, "%g", x);
  return str;
}

// returns -1 if the string is not a valid integer.
// expects a null terminated string -- if the string is not
// null terminated, undefined behavior will occur. 
// If the integer is beyond INT_MAX as defined by C, that is, 2147483647,
// overflow may occur and the result is undefined.
int int_of_str(char *str){
  // reference: https://www.geeksforgeeks.org/write-your-own-atoi/
    int res = 0;  // Initialize result 
    int sign = 1;  // Initialize sign as positive 
    int i = 0;  // Initialize index of first digit 
       
    // If number is negative, then update sign 
    if (str[0] == '-') 
    { 
        sign = -1;   
        i++;  // Also update index of first digit 
    } 
       
    // Iterate through all digits and update the result 
    for (; str[i] != '\0'; ++i) {
        if(str[i]<48 || str[i]>57) {
          // not a digit
          return -1;
        }
        res = res*10 + str[i] - '0'; 
    }
     
    // Return result with sign 
    return sign*res; 

}

// rounds float to nearest int
int int_of_float(double x){
  return (int) round(x);
}

double float_of_int(int x){
  return x * 1.0;
}

char* string_concat(char * str1, char* str2) {
	int totalLength = strlen(str1) + strlen(str2) + 1;
	char* result = calloc( totalLength, 1 );
	strcat(result, str1);
	strcat(result, str2);
	return result;
}

int string_equals(char * str1, char* str2) {
	int res = strcmp(str1, str2);
	if (res == 0) {
		return 1;
	}
	return 0;
}

// max_size doesn't have to include the terminating \0
// takes a size to malloc and which the string must be shorter than
// this max size capped at 4096.
// will remove the final trailing newline character
char* scan_line(int max_size){
  if (max_size > 4096){
    return NULL;
  }
    char *str = (char*)malloc(sizeof(char)*(max_size+1));
    memset(str, 0, max_size+1);
    fgets(str,max_size, stdin);
    if (str[strlen(str)-1] == '\n') {
      str[strlen(str)-1] = '\0'; // remove terminating newline
    }
    return str;
}

// regular successful exit
void exit_success(){
  exit(0);
  return;
}

// exit with error message
void die(char * error_msg, int code){
  printf("%s\n", error_msg);
  exit(code);
  return;
}

// assumes the str that's based in is correctly null terminated
void println(char * str){
  printf("%s\n",str);
  return;
}

// assumes the str that's based in is correctly null terminated
void print(char * str){
  printf("%s",str);
  return;
}

// call this once before calling rand_afterseed() to seed the RNG
void rand_autoseed(){
  time_t t;
  srand((unsigned)time(&t));
  return;   
}

// call this after calling rand_autoseed to get random numbers
int rand_afterseed(){
  return rand();
}

// returns empty string if newline is given
// otherwise returns the character as a string
char* scan_char(){
  char c = fgetc(stdin);
  if (c == '\n') {
    return ""; 
  }
  char *str = (char*)malloc(sizeof(char)*(2));
  memset(str, 0, 2);
  str[0] = c;
  return str;
}\\end{lstlisting}
\\end{mdframed}
