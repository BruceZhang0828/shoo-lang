
\subsubsection{fail-array-access-expr.err}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
Fatal error: exception Failure("can't access array with non-integer type")
\end{lstlisting}
\end{mdframed}
\subsubsection{fail-array-access-expr.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
array<string> a = ["hi", "bye"];
a[1.234];

\end{lstlisting}
\end{mdframed}
\subsubsection{fail-array-access-expr-string.err}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
Fatal error: exception Failure("can't access array with non-integer type")
\end{lstlisting}
\end{mdframed}
\subsubsection{fail-array-access-expr-string.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
array<string> a = ["hi", "bye"];
a[1.234];
\end{lstlisting}
\end{mdframed}
\subsubsection{fail-arraylit.err}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
Fatal error: exception Failure("empty array init is not supported")
\end{lstlisting}
\end{mdframed}
\subsubsection{fail-arraylit.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
// can't be empty
array<int> a = [];
\end{lstlisting}
\end{mdframed}
\subsubsection{fail-array-void.err}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
Fatal error: exception Parsing.Parse_error
\end{lstlisting}
\end{mdframed}
\subsubsection{fail-array-void.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
// arrays can't be of type void
array<void> a;
\end{lstlisting}
\end{mdframed}
\subsubsection{fail-binop-floats-ints.err}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
Fatal error: exception Semant.Type_mismatch("type mismatch error sint sfloat")
\end{lstlisting}
\end{mdframed}
\subsubsection{fail-binop-floats-ints.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
int a = 5;
float b = 6;

float c = a + b;

if (c == 11) {
    println("oh no");
} else {
    println("okay");
}
\end{lstlisting}
\end{mdframed}
\subsubsection{fail-call-nonfunc.err}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
Fatal error: exception Failure("not a function")
\end{lstlisting}
\end{mdframed}
\subsubsection{fail-call-nonfunc.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
int foo = 5; foo();\end{lstlisting}
\end{mdframed}
\subsubsection{fail-compare-floats-ints.err}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
Fatal error: exception Failure("Error: cannot use == with types: sfloat and sint")
\end{lstlisting}
\end{mdframed}
\subsubsection{fail-compare-floats-ints.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
int a = 5;
float b = 5.0;

if (a == b) {
    println("?");
} else {
    println("wow");
}
\end{lstlisting}
\end{mdframed}
\subsubsection{fail-destruct-scope.err}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
Fatal error: exception Failure("funner already declared")\end{lstlisting}
\end{mdframed}
\subsubsection{fail-destruct-scope.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
// destructing structs and scoping
struct FunParam {
	int funner = 90;
	string msg = "MY MESSAGE";
}


FunParam par = new(FunParam);
int funner = 188;
string msg = "VARS";
// here the below is syntactic sugar for int funner... so it won't work
{funner; msg; } = par;

println(msg);\end{lstlisting}
\end{mdframed}
\subsubsection{fail-elif-without-if.err}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
Fatal error: exception Parsing.Parse_error
\end{lstlisting}
\end{mdframed}
\subsubsection{fail-elif-without-if.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
float b = 0.23;

elif (b < 0) {
    println("what?");
} else {
    println("how?");
}

println("nothing");
\end{lstlisting}
\end{mdframed}
\subsubsection{fail-else-without-if.err}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
Fatal error: exception Parsing.Parse_error
\end{lstlisting}
\end{mdframed}
\subsubsection{fail-else-without-if.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
float b = 0.23;

else {
    println("how?");
}

println("nothing");
\end{lstlisting}
\end{mdframed}
\subsubsection{fail-empty-arr.err}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
Fatal error: exception Failure("empty array init is not supported")\end{lstlisting}
\end{mdframed}
\subsubsection{fail-empty-arr.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
array<string> empty = [];\end{lstlisting}
\end{mdframed}
\subsubsection{fail-fcall.err}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
Fatal error: exception Failure("argument type mismatch")
\end{lstlisting}
\end{mdframed}
\subsubsection{fail-fcall-rec-mutual.err}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
Fatal error: exception Semant.Undeclared_reference("undeclared reference bar")
\end{lstlisting}
\end{mdframed}
\subsubsection{fail-fcall-rec-mutual.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
function foo(int n) int {
  if (n == 1) {
    return 0;
  }
  return bar(n - 1);
}

function bar(int n) int {
  if (n == 1) {
    return 0;
  }
  return foo(n - 1);
}

println(str_of_int(foo(5)));\end{lstlisting}
\end{mdframed}
\subsubsection{fail-fcall.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
println(5);\end{lstlisting}
\end{mdframed}
\subsubsection{fail-func-missing-return.err}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
Fatal error: exception Semant.Type_mismatch("type mismatch error svoid sint")
\end{lstlisting}
\end{mdframed}
\subsubsection{fail-func-missing-return.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
function hi(int q) int {
    q+5;
}

hi(8);
\end{lstlisting}
\end{mdframed}
\subsubsection{fail-if-dead-code.err}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
Fatal error: exception Failure("dead code after return")
\end{lstlisting}
\end{mdframed}
\subsubsection{fail-if-dead-code.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
struct C {
    int a;
    int b;
}

function deadCode (C something) string {
    if (something.a != something.b) {
        return "not same";
    } else {
        return "same";
    }   

    return "neither";
}

C thing = { a = 5; b = 5;};
deadCode(thing);
\end{lstlisting}
\end{mdframed}
\subsubsection{fail-if-without-expr.err}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
Fatal error: exception Parsing.Parse_error
\end{lstlisting}
\end{mdframed}
\subsubsection{fail-if-without-expr.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
if () {
    println("wow");
}
\end{lstlisting}
\end{mdframed}
\subsubsection{fail-illegal-char.err}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
Fatal error: exception Failure("illegal character $")
\end{lstlisting}
\end{mdframed}
\subsubsection{fail-illegal-char.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
int $a = 5;
\end{lstlisting}
\end{mdframed}
\subsubsection{fail-illegal-voidparam.err}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
Fatal error: exception Parsing.Parse_error
\end{lstlisting}
\end{mdframed}
\subsubsection{fail-illegal-voidparam.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
function foo(void x) int {
    return 5;
}\end{lstlisting}
\end{mdframed}
\subsubsection{fail-loops-init.err}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
Fatal error: exception Failure("Error: sint is not a boolean type")\end{lstlisting}
\end{mdframed}
\subsubsection{fail-loops-init.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
// failiure because while only takes boolean in field

while(1){
	println("hello");
}\end{lstlisting}
\end{mdframed}
\subsubsection{fail-mult-types.err}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
Fatal error: exception Failure("a already declared")\end{lstlisting}
\end{mdframed}
\subsubsection{fail-mult-types.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
int a = 4;
float a = 5.4;\end{lstlisting}
\end{mdframed}
\subsubsection{fail-nested-func-scope.err}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
Fatal error: exception Semant.Undeclared_reference("undeclared reference bar")
\end{lstlisting}
\end{mdframed}
\subsubsection{fail-nested-func-scope.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
function foo(int x) void {
    function baz(int y) int {
        return x + y;
    }

    function bar() int {
        return baz(2);
    }
}

function main() void {
    println(str_of_int(bar()));
}

main();
\end{lstlisting}
\end{mdframed}
\subsubsection{fail-pop-int-dec.err}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
Fatal error: exception Failure("assignment for IntLit(12)\n    -\n    IntLit(1)not implemented in codegen")
\end{lstlisting}
\end{mdframed}
\subsubsection{fail-pop-int-dec.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
12--;\end{lstlisting}
\end{mdframed}
\subsubsection{fail-return-type-mismatch.err}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
Fatal error: exception Semant.Type_mismatch("type mismatch error sstring sint")\end{lstlisting}
\end{mdframed}
\subsubsection{fail-return-type-mismatch.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
function test() int {
	int a = 4;
	return "hello";
}\end{lstlisting}
\end{mdframed}
\subsubsection{fail-scoping.err}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
Fatal error: exception Failure("message already declared")\end{lstlisting}
\end{mdframed}
\subsubsection{fail-scoping.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
string msg = "comment ca va?";
// scoping for parameters vs locals
function hello1(string message) void {
	string message = "comme ci comme ca";
	println(message);
}

hello1(msg);\end{lstlisting}
\end{mdframed}
\subsubsection{fail-toplevel-return.err}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
Fatal error: exception Failure("illegal return statement")
\end{lstlisting}
\end{mdframed}
\subsubsection{fail-toplevel-return.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
return;\end{lstlisting}
\end{mdframed}
\subsubsection{fail-type-promo.err}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
Fatal error: exception Failure("Error: cannot use + with types: sfloat and sint")\end{lstlisting}
\end{mdframed}
\subsubsection{fail-type-promo.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
int x = 5;
float y = 4.0;

x+y;\end{lstlisting}
\end{mdframed}
\subsubsection{fail-unop.err}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
Fatal error: exception Semant.Type_mismatch("Type mismatch for unary operator")\end{lstlisting}
\end{mdframed}
\subsubsection{fail-unop.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
bool x = -true;
\end{lstlisting}
\end{mdframed}
\subsubsection{test-array-2d.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
0
5
\end{lstlisting}
\end{mdframed}
\subsubsection{test-array-2d.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
array<array<int>> a = new(array<array<int>>[2]);

a[0] = new(array<int>[3]);
a[1] = new(array<int>[100]);

for (int i = 0; i < 2; i++) {
  for (int j = 0; j < 3; j++) {
    a[i][j] = i * j;
  }
}

println(str_of_int(a[0][0]));
a[1][50]=5;
println(str_of_int(a[1][50]));
\end{lstlisting}
\end{mdframed}
\subsubsection{test-array-access-expr.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
3
\end{lstlisting}
\end{mdframed}
\subsubsection{test-array-access-expr.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
array<int> a = [1,2];
a[0+1] = 3;
println(str_of_int(a[1]));
\end{lstlisting}
\end{mdframed}
\subsubsection{test-array-access.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
0
1
2
3
4
5
6
7
8
\end{lstlisting}
\end{mdframed}
\subsubsection{test-array-access.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
array<int> a = [0,1,2];
println(str_of_int(a[0]));
println(str_of_int(a[1]));
println(str_of_int(a[2]));

a[2] = 3;
println(str_of_int(a[2]));

function foo() array<int> {
    array<int> a = [4,5,6,7,8];
    return a;
}

println(str_of_int(foo()[0]));
println(str_of_int(foo()[1]));
println(str_of_int(foo()[2]));
println(str_of_int(foo()[3]));
println(str_of_int(foo()[4]));
\end{lstlisting}
\end{mdframed}
\subsubsection{test-array-lift.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
hi
true
false
\end{lstlisting}
\end{mdframed}
\subsubsection{test-array-lift.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
function redeclareArray(array<bool> b) array<bool> {
    b = [true,false,true];
    return b;
}

array<bool> z;
redeclareArray(z);

array<int> x = [5,10];
function bar() void {
    x[0] = 9;
    return;
}

array<string> s;
function car() void {
    s = new(array<string>[5]);
}
car();
s[0] = "hi";
println(s[23-23]);

function declareArray(int size) array<bool> {
    array<bool> b = new(array<bool>[size]);
    return b;
}

array<bool> c = declareArray(2);
c[1] = true;
println(str_of_bool(c[1]));

c = redeclareArray(c);
println(str_of_bool(c[1]));
\end{lstlisting}
\end{mdframed}
\subsubsection{test-arraylit.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
\end{lstlisting}
\end{mdframed}
\subsubsection{test-arraylit.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
[5,6];

array<string> a;
a = ["4","3"];
a = ["2","5","6"]; // arrays are kind of dynamic 

array<float> b = [0.6,2.22,5.6,7.0];

array<int> c = [1, 3+4, 2];

array<bool> d = [true, false, true, 3 < 4];

struct A {
    int a;
    int b = 5;
}

A z;
A x;
A y;
A w;
array<A> e = [z, x, y, w];

function foo() string {
    return "hi";
}

function bar() string {
    return "bye";
}

function baz() string {
    return "bye bye";
}

array<func(; string)> q;
q = [foo, bar, baz];

array<string> p;
p = [foo(), bar(), baz()];

array<array<string>> f = [["hi","ki"], ["ok"], ["l","r","m"]];

\end{lstlisting}
\end{mdframed}
\subsubsection{test-array-new.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
0
1
2
3
4
100
hi
\end{lstlisting}
\end{mdframed}
\subsubsection{test-array-new.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
array<int> a = new(array<int>[5]);
a[0] = 0;
a[1] = 1;
a[2] = 2;
a[3] = 3;
a[4] = 4;

for (int i = 0; i < 5; i++) {
    println(str_of_int(a[i]));
}

a[3] = 100;
println(str_of_int(a[3]));

array<string> b = new(array<string>[1]);
b[0] = "hi";
println(b[0]);

array<float> c = new(array<float>[100]);
c[22] = 6.0;

array<bool> d = new(array<bool>[3]);
d[2] = true;

// array of struct type is another test
// because the array and struct access together is complicated
\end{lstlisting}
\end{mdframed}
\subsubsection{test-array-of-struct.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
5
6
7
\end{lstlisting}
\end{mdframed}
\subsubsection{test-array-of-struct.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
struct B {
    int i;
}

array<B> e = new(array<B>[3]);

for(int i = 0; i < 3; i++) {
    e[i] = new(B);
}

B a = e[0];
a.i = 5;
println(str_of_int(a.i));

B b = e[1];
b.i = 6;
println(str_of_int(b.i));

B c = e[2];
c.i = 7;
println(str_of_int(c.i));
\end{lstlisting}
\end{mdframed}
\subsubsection{test-array-size-runtime.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
true
false
\end{lstlisting}
\end{mdframed}
\subsubsection{test-array-size-runtime.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
function set_size(int n) array<bool> {
    array<bool> b = new(array<bool>[n]);
    return b;
}

array<bool> c = set_size(10);
c[9] = true;
println(str_of_bool(c[9]));
c[9] = false;
println(str_of_bool(c[9]));
\end{lstlisting}
\end{mdframed}
\subsubsection{test-arrays-structs-fns.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
2
3
\end{lstlisting}
\end{mdframed}
\subsubsection{test-arrays-structs-fns.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
struct Box {
	int width;
	int length;
}

Box box1 = new(Box);
box1.width = 8;
box1.length = 40;

Box box2 = new(Box);
box2.width = 2;
box2.length = 3;

Box box3 = new(Box);
box3.width = 9;
box3.length = 70;

Box box4 = new(Box);
box4.width = 3;
box4.length = 5;

function fun(array<Box> tester, int sz) void {
	tester[0].width = 5;
	println(str_of_int(tester[sz-1].width));
}


array<Box> test = [box1, box2];

array<Box> test2;
test2 = new(array<Box>[2]);
test2[0] = box3;
test2[1] = box4;

fun(test, 2);
fun(test2, 2);\end{lstlisting}
\end{mdframed}
\subsubsection{test-array-struct-access.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
5true
\end{lstlisting}
\end{mdframed}
\subsubsection{test-array-struct-access.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
array<int> p = new(array<int>[3]);

struct B {
    int i = 5;
}
B z = new(B);
z.i = 4;
p[0] = z.i;
array<B> e = new(array<B>[2]);
e[0] = new(B);
e[0].i = 5; // TODO the problem is still here

print(str_of_int(e[0].i));

struct C {
    array<bool> b; 
    B j;
}

C y = new(C);
y.b = new(array<bool>[5]);
y.b[0] = true;
println(str_of_bool(y.b[0]));
\end{lstlisting}
\end{mdframed}
\subsubsection{test-arrs-of-structs-w-funcs.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
34\end{lstlisting}
\end{mdframed}
\subsubsection{test-arrs-of-structs-w-funcs.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
//more testing with arrays of structs with functions that take in structs with arrays of arrays of structs as arguments

struct InnerLevel {
	array<int> deepArray = [3,34,83,4,2];
	int msgCode = 6;
}

struct StuffInArr {
	array<InnerLevel> midArray= new(array<InnerLevel>[4]);
	int x = 16;
}

function populateStuffInArr(StuffInArr temp, int sz) void {
	for (int i = 0; i < sz; i++) {
		temp.midArray[i] = new(InnerLevel);
		temp.midArray[i].msgCode = i;
	}
}

struct MoreStuff {
	array<StuffInArr> topArray= new(array<StuffInArr>[5]);
	float boo = 16.9;
}

function populateMoreStuff(MoreStuff temp, int sz) void {
	for (int i = 0; i < sz; i++) {
		temp.topArray[i] = new(StuffInArr);
		populateStuffInArr(temp.topArray[i], 4);
		temp.topArray[i].x = i;
	}
}

struct Complex{
	func (MoreStuff;StuffInArr) hello = function (MoreStuff moar) StuffInArr {
		println(str_of_int(moar.topArray[0].midArray[2].deepArray[1]));
		return moar.topArray[3];
	};
	MoreStuff aStuff = new(MoreStuff);
}

array<Complex> myArr = new(array<Complex>[6]);

// initialize
for(int i = 0; i <6; i++) {
	myArr[i] = new(Complex);
	populateMoreStuff(myArr[i].aStuff, 5);
}

// this works
myArr[0].hello(myArr[0].aStuff);

// the below commented out line does not work
// it compiles but the executable coredumps
//myArr[0].hello(new(MoreStuff));\end{lstlisting}
\end{mdframed}
\subsubsection{test-assign.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
Hello World
Hello World
Hello World
8
\end{lstlisting}
\end{mdframed}
\subsubsection{test-assign.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
string foo;
foo = "Hello World";
string bar = "bar";
bar = "Hello World";
func(;string) baz;
baz = function() string { return "Hello World"; };
int x = 5;
x = x + 3;
println(foo);
println(bar);
println(baz());
println(str_of_int(x));\end{lstlisting}
\end{mdframed}
\subsubsection{test-assoc-dot.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
10\end{lstlisting}
\end{mdframed}
\subsubsection{test-assoc-dot.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
struct More{
	int defield = 10;
	float hello = 5.5;
}

struct Stuff {
	int field = 5;
	string msg = "hello";
	More moreStuff = new(More);
}

Stuff temp = new(Stuff);
println(str_of_int(temp.moreStuff.defield));\end{lstlisting}
\end{mdframed}
\subsubsection{test-binop-eq.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
\end{lstlisting}
\end{mdframed}
\subsubsection{test-binop-eq.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
string x = "Hello "+"World"+"!";
string y = "what";
x==y;
int i = 0;
int j = 0;
i!=j;\end{lstlisting}
\end{mdframed}
\subsubsection{test-binop-expression.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
6\end{lstlisting}
\end{mdframed}
\subsubsection{test-binop-expression.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
int x;
x =  5 + (4-2)/2;
println(str_of_int(x));\end{lstlisting}
\end{mdframed}
\subsubsection{test-binop.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
11
6
2
2.25
2
2
true
false
true 
true
yes good
yes good
&& works
&& works
&& works
&& works
|| works
|| works
|| works
|| works
! works
! works
\end{lstlisting}
\end{mdframed}
\subsubsection{test-binop.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
int x = 5+6;
println(str_of_int(x));
int y = 2*3;
println(str_of_int(y));

int me = 5/2;
println(str_of_int(me));

float hello = 4.5/2.0;
println(str_of_float(hello));

int z = y % 4;
println(str_of_int(z));

z = z % 4;
println(str_of_int(z));

bool q = z < x;
println(str_of_bool(z < x));

q = z > x; 
println(str_of_bool(q));

q = z >= 2;
println(str_of_bool(q));

q = z <= 2;
println(str_of_bool(q));

if (x==y) {
	println("SHOULDNT PRINT THIS");
} else {
	println("yes good");
}

if (x!=y) {
	println("yes good");
} else {
	println("SHOULDNT PRINT THIS");
}


// AND, OR, NOT
bool i = true;
bool j = false;

if (j && i) {
    println("&& doesn't work");
} else {
    println("&& works");
}

if (i && j) {
    println("&& doesn't work");
} else {
    println("&& works");
}

if (i && true) {
    println("&& works");
} else {
    println("&& doesn't work");
}

if (j && false) {
    println("&& doesn't work");
} else {
    println("&& works");
}

if (i || j) {
    println("|| works");
} else {
    println("|| doesn't work");
}

if (j || i) {
    println("|| works");
} else {
    println("|| doesn't work");
}

if (true || i) {
    println("|| works");
} else {
    println("|| doesn't work");
}

if (j || false) {
    println("|| doesn't work");
} else {
    println("|| works");
}

if (!i) {
    println("! doesn't work");
} else {
    println("! works");
}

if (!j) {
    println("! works");
} else {
    println("! doesn't work");
}

\end{lstlisting}
\end{mdframed}
\subsubsection{test-binop-str.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
Hello World!
Hello World!
yay
\end{lstlisting}
\end{mdframed}
\subsubsection{test-binop-str.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
string x = "Hello "+"World"+"!";
println(x);

string y = string_concat("Hello ","World");
y = string_concat(y, "!");
println(y);

if (x == y) {
     println("yay");
} else {
    println("not yay");
}
\end{lstlisting}
\end{mdframed}
\subsubsection{test-bubblesort-array-fcall-struct.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
1
3
8
6
9
7
0
2
4
5
106
101
104
108
105
103
102
109
107
100
0
1
2
3
4
5
6
7
8
9
100
101
102
103
104
105
106
107
108
109
\end{lstlisting}
\end{mdframed}
\subsubsection{test-bubblesort-array-fcall-struct.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
struct Object {
	int index;
	int data;
}

function compareData(Object a, Object b) bool {
    return a.data < b.data;
}

function compareIndex(Object a, Object b) bool {
    return a.index < b.index;
}

function printData(array<Object> arr, int n) void {
	for (int i = 0; i < n; i++) {
		println(str_of_int(arr[i].data));
	}
	
	return;
}

function printIndex(array<Object> arr, int n) void {
	for (int i = 0; i < n; i++) {
		println(str_of_int(arr[i].index));
	}
	
	return;
}

function bubbleSort(array<Object> arr, int n, func(Object, Object; bool) compare) array<Object> {
	for (int i = 0; i < n - 1; i++) {
		for (int j = 0; j < n - i - 1; j++) {
			if (compare(arr[j + 1], arr[j])) {
				Object temp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = temp;
			}
		}
	}
	
	return arr;
}

array<int> indices = [1,3,8,6,9,7,0,2,4,5];
array<int> datapoints = [106,101,104,108,105,103,102,109,107,100];

int n = 10;
array<Object> objects = new(array<Object>[n]);

for (int i = 0; i < n; i++) {
	objects[i] = new(Object);
	objects[i].index = indices[i]; 
	objects[i].data = datapoints[i];
}

printIndex(objects, n);
printData(objects, n);

bubbleSort(objects, n, compareIndex);
printIndex(objects, n);

bubbleSort(objects, n, compareData);
printData(objects, n);



\end{lstlisting}
\end{mdframed}
\subsubsection{test-builtin-as-firstclass.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
hello world1234
5
\end{lstlisting}
\end{mdframed}
\subsubsection{test-builtin-as-firstclass.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
function foo(func(string;void) bar, func(int;string) baz) void {
  bar("hello world" + baz(1234));
  return;
}

foo(println, str_of_int);

struct B {
    func(float; string) a = str_of_float;
    float b = 5.0;
    string c;
}

B someStruct = new(B);
someStruct.c = someStruct.a(someStruct.b);
println(someStruct.c);

\end{lstlisting}
\end{mdframed}
\subsubsection{test-builtins-firstclass.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
6\end{lstlisting}
\end{mdframed}
\subsubsection{test-builtins-firstclass.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
// make struct with function as a member field

struct First {
	func (int;string) intToString;
	int default = 5;
}

First temp = new(First);
temp.intToString = str_of_int;

println(temp.intToString(6));\end{lstlisting}
\end{mdframed}
\subsubsection{test-builtins.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
HI
BYE
GOOD
5
5.5
5.245
2.456\end{lstlisting}
\end{mdframed}
\subsubsection{test-builtins.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
int x = int_of_float(4.5);
float y = float_of_int(4);

if(x==5){
	println("HI");
}

if(y==4.0){
	println("BYE");
}
float result = y + 1.0;

if(result < 6.0){
	println("GOOD");
}

string testInt = "5";
int resultMore = int_of_str(testInt);
println(str_of_int(resultMore));

string hello = str_of_float(4.5+1.0);
println(hello);

string hello1 = str_of_float(y+1.245);
println(hello1);

println(str_of_float(2.456));

//test regular exit
exit_success();

println("THIS SHOULDNT PRINT");\end{lstlisting}
\end{mdframed}
\subsubsection{test-compare-arrays.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
same ptr
same
same value not same ptr
not equal at all
yes
\end{lstlisting}
\end{mdframed}
\subsubsection{test-compare-arrays.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
array<int> a = [1,2,3,4,5];
array<int> b = [1,2,3,4,5];
array<int> c = [5,4,3,2,1];
array<int> d = [2,3];

function temp(array<int> g) void{
    if (g == a) {
        println("same ptr");
    } else {
        println("diff ptr");
    }
}

temp(a);

if (a == a) {
    println("same");
} else {
    println("what");
}

if (a == b) {
    println("same values");
} else {
    println("same value not same ptr"); 
}

if (a == c) {
    println("equal?");
} else {
    println("not equal at all");
}

if (b == d) {
    println("no");
} else {
    println("yes");
}



\end{lstlisting}
\end{mdframed}
\subsubsection{test-compare-primitives.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
int works
int works
int works
float works
float works
float works
float works
bool works
bool works
bool works
bool works
\end{lstlisting}
\end{mdframed}
\subsubsection{test-compare-primitives.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
int a = 5;
int b = 5;

if (a == b) {
    println("int works");
} else {
    println("int doesn't work");
}

int c = 6;

if (a == c) {
    println("int doesn't work");
} else {
    println("int works");
}

if (a == a) {
    println("int works");
} else {
    println("int doesn't work");
}

// floats
float d = 1.098;
float e = 1.098;

if (d == e) {
    println("float works");
} else {
    println("float doesn't work");
}

float f = 2.45678900;
if (d == f) {
    println("float doesn't work");
} else {
    println("float works");
}

float g = 1.0980;
if (d == g) {
    println("float works");
} else {
    println("float doesn't work");
}

if (d == d) {
    println("float works");
} else {
    println("float doesn't work");
}

// booleans
bool h = true;
bool i = true;

if (h == i) {
    println("bool works");
} else {
    println("bool doesn't work");
}

bool j = false;
if (h == j) {
    println("bool doesn't work");
} else {
    println("bool works");
}

bool k = 0 < 5;
if (h == k) {
    println("bool works");
} else {
    println("bool doesn't work");
}

if (h == h) {
    println("bool works");
} else {
    println("bool doesn't work");
}

\end{lstlisting}
\end{mdframed}
\subsubsection{test-compare-strings.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
strings are equal
strings are equal
built-in
is zero
\end{lstlisting}
\end{mdframed}
\subsubsection{test-compare-strings.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
string z = "hijjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjj";
string q = "hijjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjj";

if (q == z) {
    println("strings are equal");
} else {
    println("strings aren't equal");
}

function something(string s) string {
    string h = "h";
    string j = h + s;
    return j;
}

string p = something("ijjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjj");
if (p == z) {
    println("strings are equal");
} else {
    println("strings aren't equal");
} 


string s1 = "hi";
string s2 = "hi";
if (string_equals(s1, s2) == 1) {
    println("built-in");
} else {
    println("not built-in");
}

s2 = "bye";
if (string_equals(s1, s2) == 1) {
    println("is one");
} elif (string_equals(s1, s2) == 0) {
    println("is zero");
} else {
    println("is other");
}

\end{lstlisting}
\end{mdframed}
\subsubsection{test-declaring-two-structs.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
no
\end{lstlisting}
\end{mdframed}
\subsubsection{test-declaring-two-structs.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
struct B {
   int a;
   float c;
}

struct C {
   int a;
   float b;
}

B h = { a = 0; c = 2.09; };

B g = { a = 3; c = 3.09; };

C k = { a = 5; b = 1.23; };
C w;
w = { a = 6; b = 2.456; };

if (5 == 5) {
   println("no");
} else {
   println("yes");
}\end{lstlisting}
\end{mdframed}
\subsubsection{test-default-values-structs.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
10
PRINTING THIS
GOOD WE WANT TO PRINT
\end{lstlisting}
\end{mdframed}
\subsubsection{test-default-values-structs.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
struct TestStruct {
	int hello = 5;
	string msg = "PRINTING THIS";
	string num = "10";
	func(int;int) intToInt;
}

// all struct use requires new
TestStruct temp = new(TestStruct);

int numAsInt = int_of_str(temp.num);
println(str_of_int(numAsInt));

println(temp.msg);

if (temp.hello==5) {
	println("GOOD WE WANT TO PRINT");
} else {
	println("BOO");
}\end{lstlisting}
\end{mdframed}
\subsubsection{test-destruct.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
10
5
\end{lstlisting}
\end{mdframed}
\subsubsection{test-destruct.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
struct Foo {
  int x = 10;
  int y = 5;
}

Foo myFoo = new(Foo);


{ x; y; } = myFoo;

println(str_of_int(x));
println(str_of_int(y));
\end{lstlisting}
\end{mdframed}
\subsubsection{test-dot-and-array.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
100
\end{lstlisting}
\end{mdframed}
\subsubsection{test-dot-and-array.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}

struct Foo {
  array<int> foo = [1, 2, 3];
}

struct Bar {
  array<Foo> bar = [new(Foo), new(Foo), new(Foo)];
}

struct Baz {
  array<Bar> baz = [new(Bar), new(Bar), new(Bar)];
}

Baz b = new(Baz);

function setItem(Baz x) void {
  x.baz[0].bar[0].foo[1] = 100;
  return;
}

setItem(b);

println(str_of_int(b.baz[0].bar[0].foo[1]));

\end{lstlisting}
\end{mdframed}
\subsubsection{test-dynamic-size-array.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
4
0
\end{lstlisting}
\end{mdframed}
\subsubsection{test-dynamic-size-array.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
int x = 5;
array<int> arr = new(array<int>[x]);
arr[x-1] = 4;
arr[x-2] = 0;
println(str_of_int(arr[x-1]));
println(str_of_int(arr[x-2]));\end{lstlisting}
\end{mdframed}
\subsubsection{test-empty-arr.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
empty\end{lstlisting}
\end{mdframed}
\subsubsection{test-empty-arr.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
array<int> stuff = new(array<int>[0]);
println("empty");\end{lstlisting}
\end{mdframed}
\subsubsection{test-empty-structs.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
\end{lstlisting}
\end{mdframed}
\subsubsection{test-empty-structs.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
struct Empty{
}

Empty temp;

Empty temp2 = new(Empty);\end{lstlisting}
\end{mdframed}
\subsubsection{test-exit.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
Hello
AHH!!!!\end{lstlisting}
\end{mdframed}
\subsubsection{test-exit.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
println("Hello");
die("AHH!!!!",0);
println("this shouldn't print");\end{lstlisting}
\end{mdframed}
\subsubsection{test-fcall-rec.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
3\end{lstlisting}
\end{mdframed}
\subsubsection{test-fcall-rec.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
function countdown(int n) int {
    if (n == 1) { return 1; }
    
    return countdown(n - 1) + 1;
}

println(str_of_int(countdown(3)));
\end{lstlisting}
\end{mdframed}
\subsubsection{test-fcall-simple.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
Hello World
\end{lstlisting}
\end{mdframed}
\subsubsection{test-fcall-simple.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
function foo() string {
  return "Hello World";
}
println(foo());\end{lstlisting}
\end{mdframed}
\subsubsection{test-fibonacci.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
34
\end{lstlisting}
\end{mdframed}
\subsubsection{test-fibonacci.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
function fib(int n) int {
    if (n <= 1) {
        return n;
    }

    return fib(n-1) + fib(n-2);
}

println(str_of_int(fib(9)));
\end{lstlisting}
\end{mdframed}
\subsubsection{test-for-loop-missing-all.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
done!
\end{lstlisting}
\end{mdframed}
\subsubsection{test-for-loop-missing-all.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
function infinite(int c) string {
    for ( ; ; ) {
        c = c + 1;
        if (c > 100) {
            return "done!";
        }
    }
    
    return "what??";
}

string s = infinite(2);
println(s);
\end{lstlisting}
\end{mdframed}
\subsubsection{test-for-loop-no-incr.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
hello 0
hello 2
hello 4
hello 6
hello 8
\end{lstlisting}
\end{mdframed}
\subsubsection{test-for-loop-no-incr.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
for (int i = 0; i < 10;  ) {
    println("hello " + str_of_int(i));
    i = i + 2;
}
\end{lstlisting}
\end{mdframed}
\subsubsection{test-for-loop-no-init.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
0
1
2
3
4
\end{lstlisting}
\end{mdframed}
\subsubsection{test-for-loop-no-init.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
int i = 0;
for (; i < 5; i = i + 1) {
    println(str_of_int(i));
}
\end{lstlisting}
\end{mdframed}
\subsubsection{test-for-loop-no-predicate.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
100
\end{lstlisting}
\end{mdframed}
\subsubsection{test-for-loop-no-predicate.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
function hi() int {
    for (int k = 1; ; k = k + 7) {
        if (k > 100) {
            return 100;
        }
    }
    return 1;
}

println(str_of_int(hi())); 
\end{lstlisting}
\end{mdframed}
\subsubsection{test-for-loop.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
hello 0
hello 1
hello 2
hello 3
hello 4
\end{lstlisting}
\end{mdframed}
\subsubsection{test-for-loop-return.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
hello 5
\end{lstlisting}
\end{mdframed}
\subsubsection{test-for-loop-return.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}


function foo() string {
  for (int i = 5; i < 10; i = i+1) {
    return "hello " + str_of_int(i);
  }
}

println(foo());\end{lstlisting}
\end{mdframed}
\subsubsection{test-for-loop.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
for (int i = 0; i < 5; i++) {
    println("hello " + str_of_int(i));
}
\end{lstlisting}
\end{mdframed}
\subsubsection{test-freturn-void.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
\end{lstlisting}
\end{mdframed}
\subsubsection{test-freturn-void.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
function foo() void {
  return;
}
foo();

function bar() void {
}
\end{lstlisting}
\end{mdframed}
\subsubsection{test-func-modify-array-scope.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
2
bye
\end{lstlisting}
\end{mdframed}
\subsubsection{test-func-modify-array-scope.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
// Returns a function to return the value at a specific, static index for an array
function indexValue (array<int> arr, int index1)  func(; string) {
    // Assume the index is vaild.
    return function() string {
        return str_of_int(arr[index1]);
        //return problem.s[index];
    };
}

array<int> a = [1,2,3];
func(; string) print1ForArray = indexValue(a, 1);
println(print1ForArray()); // should print 2

struct MyArray {
    array<string> s;
    int size;
}

MyArray a1 = { s = ["hi", "bye", "okay"]; size = 3; };

// Returns a function to return the value at a specific, static index for struct
function indexValueStruct (MyArray problem, int index2)  func(; string) {
    // Assume the index is vaild.
    return function() string {
        return problem.s[index2]; 
    };
}

func(; string) print1ForStruct = indexValueStruct(a1, 1);
println(print1ForStruct()); // should print bye
\end{lstlisting}
\end{mdframed}
\subsubsection{test-func-ret-func.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
11\end{lstlisting}
\end{mdframed}
\subsubsection{test-func-ret-func.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
function makeAdd (int add) func(int;int) {

	return function (int value) int {
		return add + value;
	};
}

// make a function that adds 5 to the input
func(int;int) myAdd = makeAdd(5);

int x = 6;

println(str_of_int(myAdd(6)));
\end{lstlisting}
\end{mdframed}
\subsubsection{test-hello2.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
Hello World!
\end{lstlisting}
\end{mdframed}
\subsubsection{test-hello2.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
function create_get_hello() func(;string) {
  string x = "Hello";
  return function() string {
    return x;
  };
}

function create_hello_func() func(string;string) {
  string y = create_get_hello()() + " ";
  return function(string name) string {
    return y + name + "!";
  };
}

println(create_hello_func()("World"));\end{lstlisting}
\end{mdframed}
\subsubsection{test-hello.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
Hello World
\end{lstlisting}
\end{mdframed}
\subsubsection{test-hello.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
function foo() func(int;string) {
  string x = "Hello World";
  return function(int y) string {
    return x;
  };
}
println(foo()(5));\end{lstlisting}
\end{mdframed}
\subsubsection{test-if.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
GOOD
JOB
yes
0
\end{lstlisting}
\end{mdframed}
\subsubsection{test-if-return.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
correct
correct
2
3
\end{lstlisting}
\end{mdframed}
\subsubsection{test-if-return.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
function foo() string {
    string x = "Hello "+"World"+"!";
    string y = "what";
    if (x!=y) {
        return "correct";
    } else {
        return "incorrect";
    }
}
println(foo());

function bar() string {
    float x = 1.0909;
    float y = 2.898;
    if (x==y) {
        return "incorrect";
    } elif (x > y) {
        return "incorrect";
    } elif (x < y) {
        return "correct";
    } else {
        return "incorrect";
    }
}
println(bar());


function someReturn(float a) string {
    if (a == 25.9) {
        return "okay";
    } else {
        
    }
    
    return "maybe";
}

someReturn(25.9);

function other(bool b) int {
    int a = 1;
    if (b) {
        a++;
    } elif (false) {
        a = 0;
    } else {
        return a + other(true);
    }
    return a;
}

println(str_of_int(other(true)));
println(str_of_int(other(false)));
\end{lstlisting}
\end{mdframed}
\subsubsection{test-if.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
string x = "Hello "+"World"+"!";
string y = "what";
if (x!=y) {
	println("GOOD");
} else {
	println("SHOULDNT HAVE PRINTED THIS");
}

int i = 0;
int j = 0;
if(i==j) {
	println("JOB");
}

if (i > 1) {
    println("no");
} elif (i == 0) {
    println("yes");
} else {
    println("none");
}

if (i == 0) {

} else {

}


if (i == 4) {
    println(str_of_int(4));
} elif (i == 3) {
    println(str_of_int(3));
} elif (i == 2) {
    println(str_of_int(2));
} elif (i == 1) {
    println(str_of_int(1));
} elif (i == 0) {
    println(str_of_int(0));
} else {
    println("what??");
}
\end{lstlisting}
\end{mdframed}
\subsubsection{test-if-without-else.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
Yes
yes
not not
\end{lstlisting}
\end{mdframed}
\subsubsection{test-if-without-else.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
bool b = 5 < 6;
if (!b) {
    println("no");
}

println("Yes");

if (b) {
    println("yes");
}

if (!!b) {
    println("not not");
} elif (!b) {
    println("not");
}
\end{lstlisting}
\end{mdframed}
\subsubsection{test-init-structs.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
12345\end{lstlisting}
\end{mdframed}
\subsubsection{test-init-structs.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
struct BankAccount {
	int balance;
	int ownerId;
}

BankAccount myAccount; // Declare a variable of struct type BankAccount.
myAccount = {balance = 0; ownerId = 12345;};

myAccount.balance = 5;
println(str_of_int(myAccount.ownerId));\end{lstlisting}
\end{mdframed}
\subsubsection{test-loops-init.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
hello
bye
bye
bye
bye
bye
5
NICE
true
how about this?
true
how about this?
true
how about this?
true
how about this?
false
how about this?
END
stuff\end{lstlisting}
\end{mdframed}
\subsubsection{test-loops-init.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
//add tests to declare any variable of any type in the for loop; and add failure tests to not allow anything except initializations and assignments


int i = 0;
// test to show any statement can be in for loop initializer
for(println("hello"); i<5; i++){
	println("bye");
}

println(str_of_int(i));
println("NICE");
int counter = 0;

// test to use other variables than int
for(bool x = true; x; println("how about this?")){
	if(counter > 3){
		x = false;
	}
	counter++;
	println(str_of_bool(x));
}
println("END");

// while loop testing
bool f = true;
while(f){
	println("stuff");
	f = false;
}

while(f){
	println("uh shouldnt print");
}\end{lstlisting}
\end{mdframed}
\subsubsection{test-multi-arg-passing-func.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
bye
\end{lstlisting}
\end{mdframed}
\subsubsection{test-multi-arg-passing-func.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
function myPrint(func(string; string) printme, string mystring) void {
    printme(mystring);
    return;
}


function hello(string s) string {
    println(s);
    return s;
}

myPrint(hello, "bye");
\end{lstlisting}
\end{mdframed}
\subsubsection{test-multidim-arr.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
WE MADE IT\end{lstlisting}
\end{mdframed}
\subsubsection{test-multidim-arr.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
array<array<array<array<string>>>> multiDimArrMORE = new(array<array<array<array<string>>>>[10]);

multiDimArrMORE[0] = new(array<array<array<string>>>[4]);
multiDimArrMORE[0][0] = new(array<array<string>>[2]);
multiDimArrMORE[0][0][0] = new(array<string>[5]);
multiDimArrMORE[0][0][0][0] = "WE MADE IT";

println(multiDimArrMORE[0][0][0][0]);\end{lstlisting}
\end{mdframed}
\subsubsection{test-name-funs.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
9
\end{lstlisting}
\end{mdframed}
\subsubsection{test-name-funs.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
function hello() func(int;string) {
	func(int;string) namedFunction = function (int x) string {
		return str_of_int(x+5);
	};
	return namedFunction;
}

println(hello()(4));\end{lstlisting}
\end{mdframed}
\subsubsection{test-new-array-of-struct.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
10
\end{lstlisting}
\end{mdframed}
\subsubsection{test-new-array-of-struct.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}

struct B {
  int i;
}

array<B> e = new(array<B>[3]);

e[0] = { i = 10; };

println(str_of_int(e[0].i));
\end{lstlisting}
\end{mdframed}
\subsubsection{test-new-struct-default-func.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
Hello World
\end{lstlisting}
\end{mdframed}
\subsubsection{test-new-struct-default-func.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
struct A {
  int x = 10;
  func(;string) hello = function() string {
    return "Hello World";
  };
}

A foo = new(A);

println(foo.hello());
\end{lstlisting}
\end{mdframed}
\subsubsection{test-pop-int-incre.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
1
\end{lstlisting}
\end{mdframed}
\subsubsection{test-pop-int-incre.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
int i = 0;
i++;
println(str_of_int(i));\end{lstlisting}
\end{mdframed}
\subsubsection{test-pop-struct.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
6
5
\end{lstlisting}
\end{mdframed}
\subsubsection{test-pop-struct.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
struct Foo {
  int x = 5;
}

Foo f = new(Foo);
f.x++;
println(str_of_int(f.x));
f.x--;
println(str_of_int(f.x));\end{lstlisting}
\end{mdframed}
\subsubsection{test-print.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
5
5
false
false
true
true
hello
hello
hi
\end{lstlisting}
\end{mdframed}
\subsubsection{test-print.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
int a = 5;
println(str_of_int(a));
println(str_of_int(5));

// TODO need to implement str_of_float
/*float b = 1.234567;
println(str_of_float(b));
println(str_of_float(1.234567));*/

bool c = false;
println(str_of_bool(c));
println(str_of_bool(false));
bool d = true;
println(str_of_bool(d));
println(str_of_bool(true));

string e = "hello";
println(e);
println("hello");

string f = "hi";
print(f);
println("");
\end{lstlisting}
\end{mdframed}
\subsubsection{test-rec-mergesort-int.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
0
1
2
3
\end{lstlisting}
\end{mdframed}
\subsubsection{test-rec-mergesort-int.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
struct Box {
	int width;
	int length;
	int lowerLeftCorner_x;
	int lowerLeftCorner_y;
}

// perform mergesort on an array of box structs
Box box1 = new(Box);
box1.width = 5;
box1.length = 10;

Box box2 = new(Box);
box2.width = 5;
box2.length = 10;

Box box3 = new(Box);
box3.width = 5;
box3.length = 10;

Box box4 = new(Box);
box4.width = 5;
box4.length = 10;

array<Box> arr = [box1, box2, box3, box4];
array<int> test = [2, 3, 1, 0];

// reference: https://www.geeksforgeeks.org/merge-sort/
function merge(array<int> arr, int l, int m, int r) void {
	int i;
	int j;
	int k;
    int n1 = m - l + 1;
    int n2 =  r - m;
  
    /* create temp arrays */
    array<int> leftArr;
    array<int> rightArr;

    leftArr = new(array<int>[n1]);
    rightArr = new(array<int>[n2]);
  
    /* Copy data to temp arrays L[] and R[] */
    for (i = 0; i < n1; i++) {
 		leftArr[i] = arr[l+i];
    }

    for (j = 0; j < n2; j++){
        rightArr[j] = arr[m + 1+ j];
    }
  
    /* Merge the temp arrays back into arr[l..r]*/
    i = 0; // Initial index of first subarray 
    j = 0; // Initial index of second subarray 
    k = l; // Initial index of merged subarray 
    while (i < n1 && j < n2) 
    { 
        if (leftArr[i] <= rightArr[j]) 
        { 
            arr[k] = leftArr[i]; 
            i++; 
        } 
        else
        { 
            arr[k] = rightArr[j]; 
            j++; 
        } 
        k++; 
    }
  
    /* Copy the remaining elements of L[], if there 
       are any */
    while (i < n1) { 
        arr[k] = leftArr[i]; 
        i++; 
        k++; 
    }
  
    /* Copy the remaining elements of R[], if there 
       are any */
    while (j < n2) { 
        arr[k] = rightArr[j]; 
        j++; 
        k++; 
    }
}

function mergeSort(array<int> boxArr, int l, int r) void {
	// code from reference link
	if (l < r) { 
        // Same as (l+r)/2, but avoids overflow for 
        // large l and h 
        int m = l + (r-l)/2; 
  
        // Sort first and second halves 
        mergeSort(boxArr, l, m); 
        mergeSort(boxArr, m+1, r); 
  
        merge(boxArr, l, m, r); 
    } 
}

function printArr(array<int> testArr, int sz) void {
	for(int i = 0; i<sz; i++){
		println(str_of_int(testArr[i]));
	}
}

function mergeSortUser(array<int> tester, int sz) void {
	// do the merge sorting
	mergeSort(tester,0,sz-1);

	// print the array
	printArr(tester, sz);
}

mergeSortUser(test, 4);\end{lstlisting}
\end{mdframed}
\subsubsection{test-rec-mergesort-structs.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
2
8
10
12
2
8
10
12
\end{lstlisting}
\end{mdframed}
\subsubsection{test-rec-mergesort-structs.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
struct Box {
	int width;
	int length;
}

// perform mergesort on an array of box structs
Box box1 = new(Box);
box1.width = 8;
box1.length = 40;

Box box2 = new(Box);
box2.width = 2;
box2.length = 3;

Box box3 = new(Box);
box3.width = 10;
box3.length = 16;

Box box4 = new(Box);
box4.width = 12;
box4.length = 8;

// reference: https://www.geeksforgeeks.org/merge-sort/
function merge(array<Box> arr, int l, int m, int r) void {
	int i;
	int j;
	int k;
    int n1 = m - l + 1;
    int n2 =  r - m;
  
    /* create temp arrays */
    array<Box> leftArr;
    array<Box> rightArr;

    leftArr = new(array<Box>[n1]);
    rightArr = new(array<Box>[n2]);
  
    /* Copy data to temp arrays L[] and R[] */
    for (i = 0; i < n1; i++) {
 		leftArr[i] = arr[l+i];
    }

    for (j = 0; j < n2; j++){
        rightArr[j] = arr[m + 1+ j];
    }
  
    /* Merge the temp arrays back into arr[l..r]*/
    i = 0; // Initial index of first subarray 
    j = 0; // Initial index of second subarray 
    k = l; // Initial index of merged subarray 
    while (i < n1 && j < n2) 
    { 
        if (leftArr[i].width <= rightArr[j].width) 
        { 
            arr[k] = leftArr[i]; 
            i++; 
        } 
        else
        { 
            arr[k] = rightArr[j]; 
            j++; 
        } 
        k++; 
    }
  
    /* Copy the remaining elements of L[], if there 
       are any */
    while (i < n1) { 
        arr[k] = leftArr[i]; 
        i++; 
        k++; 
    }
  
    /* Copy the remaining elements of R[], if there 
       are any */
    while (j < n2) { 
        arr[k] = rightArr[j]; 
        j++; 
        k++; 
    }
}

// we are mergesorting on the width of the box
function mergeSort(array<Box> boxArr, int l, int r) void {
	// code from reference link
	if (l < r) { 
        // Same as (l+r)/2, but avoids overflow for 
        // large l and h 
        int m = l + (r-l)/2; 
  
        // Sort first and second halves 
        mergeSort(boxArr, l, m);
        mergeSort(boxArr, m+1, r); 
  
        merge(boxArr, l, m, r); 
    } 
}

function printBox(Box box) void {
	println(str_of_int(box.width));
}

function printArr(array<Box> testArr, int sz) void {
	for(int i = 0; i<sz; i++){
		printBox(testArr[i]);
	}
}

function mergeSortUser(array<Box> tester, int sz) void {
	// do the merge sorting
	mergeSort(tester,0,sz-1);

	// print the array
	printArr(tester, sz);
}

array<Box> test1;
test1 = new(array<Box>[4]);
test1[0] = box1;
test1[1] = box2;
test1[2] = box3;
test1[3] = box4;

array<Box> test = [box1, box2, box3, box4];

mergeSortUser(test, 4);
mergeSortUser(test1, 4);
\end{lstlisting}
\end{mdframed}
\subsubsection{test-return-after-for.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
Hello World
\end{lstlisting}
\end{mdframed}
\subsubsection{test-return-after-for.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
function foo() string {
  for(int i = 0; i < 10; i = i + 1) {
    int x = 5;
    x = 10;
  }
  return "Hello World";
}
println(foo());\end{lstlisting}
\end{mdframed}
\subsubsection{test-return-func-arg-scope.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
0 5 10 15 20 25 30 35 40 45 
0 1 2 3 4 5 6 7 8 9 
\end{lstlisting}
\end{mdframed}
\subsubsection{test-return-func-arg-scope.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
// This function provides a printer for arrays of a
// specific size. If the array is smaller than the 
// specified size, the output might be strange... 
function printArray (int size) func(array<float>; void) {
    return function(array<float> newArr) void {
        // Use the size from the outer scope.
        for (int i = 0; i < size; i++) {
            
            print(str_of_float(newArr[i]) + " ");
        }
        println("");
    };
}

int size = 10;

func(array<float>; void) toPrintPrinter = printArray(size);

array<float> toPrint = new(array<float>[size]);
for (int i = 0; i < size; i++) {
    toPrint[i] = float_of_int(i)*5.0;
}

toPrintPrinter(toPrint);

array<float> sameSize = [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0];
toPrintPrinter(sameSize);
\end{lstlisting}
\end{mdframed}
\subsubsection{test-scope-structs-firstclassfns.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
HI
secret message is heresecond secret message6\end{lstlisting}
\end{mdframed}
\subsubsection{test-scope-structs-firstclassfns.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
// struct of same name inside firstclass fn inside struct of same name
struct Fancy {
	int field;
	string hello;
	func(int;string) anon = function (int x) string {
		struct Fancy {
			string diff;
			string diff2;
			int storeStuff;
		}
		Fancy innerFancy = new(Fancy);
		innerFancy.diff = "secret message is here";
		innerFancy.diff2 = "second secret message";

		return innerFancy.diff + innerFancy.diff2 + str_of_int(x);
	};
}

Fancy myNew;
myNew = new(Fancy);

myNew.hello = "HI";
string result = myNew.anon(6);
println(myNew.hello);
println(result);\end{lstlisting}
\end{mdframed}
\subsubsection{test-scoping.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
ca va bien
ca va mal\end{lstlisting}
\end{mdframed}
\subsubsection{test-scoping.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
//scoping for globals vs locals

string msg = "comment ca va";

function hello() void {
	string msg = "ca va bien";
	println(msg);
}

hello();

// globals vs parameters
function hello2(string msg) void {
	println(msg);
}

hello2("ca va mal");\end{lstlisting}
\end{mdframed}
\subsubsection{test-struct-array-compar.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
EXPECTED
EXPECTED
EXPECTED
EXPECTED
EXPECTED
EXPECTED\end{lstlisting}
\end{mdframed}
\subsubsection{test-struct-array-compar.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
struct Hello {
	int age = 30;
	string greeting = "hello";
}

Hello myHello = new(Hello);
Hello yourHello = new(Hello);
Hello hi = myHello;

if(myHello == yourHello) {
	println("UNEXPECTED");
} else {
	println("EXPECTED");
}

array<string> arr = new(array<string>[5]);
array<string> arr2 = new(array<string>[5]);

array<string> arr3 = arr2;

if(arr == arr2) {
	println("UNEXPECTED");
} else {
	println("EXPECTED");
}

if(arr2 == arr3) {
	println("EXPECTED");
} else {
	println("UNEXPECTED");
}

if(arr2 == arr2) {
	println("EXPECTED");
} else {
	println("UNEXPECTED");
}

if(myHello == hi) {
	println("EXPECTED");
} else {
	println("UNEXPECTED");
}

if(myHello == myHello) {
	println("EXPECTED");
} else {
	println("UNEXPECTED");
}
\end{lstlisting}
\end{mdframed}
\subsubsection{test-struct-empty.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
does nothing
\end{lstlisting}
\end{mdframed}
\subsubsection{test-struct-empty.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
struct Empty{}
Empty e;
println("does nothing");
\end{lstlisting}
\end{mdframed}
\subsubsection{test-struct-func.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
11
\end{lstlisting}
\end{mdframed}
\subsubsection{test-struct-func.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
// Struct with function in it.
function add5(int y) int {
    return y+5;
}

struct Math {
    func(int; int) doAdd = add5;
}

Math m = new(Math);
m.doAdd = add5; // this fixes the seg fault

println(str_of_int(add5(6))); // this is fine
m.doAdd(6); // this seg faults
// println(str_of_int(m.doAdd(6)));
\end{lstlisting}
\end{mdframed}
\subsubsection{test-struct-helloworld.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
Sam says hello to Stephen for the 0th time
Sam says hello to Stephen for the 1st time
Sam says hello to Stephen for the 2nd time
Sam says hello to Stephen for the 3rd time
Sam says hello to Stephen for the 4th time
\end{lstlisting}
\end{mdframed}
\subsubsection{test-struct-helloworld.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
struct Professor {
  string name;
}

struct Student {
  string name;
  func(Professor;void) greet;
}

function createProfessor(string name) Professor {
  return { name = name; };
}

function createStudentCreator(string defaultGreeting) func(string;Student) {
  return function(string name) Student {
    function helper(int i) string {
      string x = "st";
      if (i == 0 || i == 4) {
        x = "th";
      } elif (i == 2) {
        x = "nd";
      } elif (i == 3) {
        x = "rd";
      }
      return str_of_int(i) + x;
    }
    return {
      name = name;
      greet = function(Professor p) void {
        for (int i = 0; i < 5; i = i + 1) {
          println(name + " says " + defaultGreeting + " to " + p.name + " for the " + helper(i) + " time");
        }
        return;
      };
    };
  };
}

Professor stephen = createProfessor("Stephen");

createStudentCreator("hello")("Sam").greet(stephen);\end{lstlisting}
\end{mdframed}
\subsubsection{test-struct-init.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
MALLOC DOES WORK
5
hello\end{lstlisting}
\end{mdframed}
\subsubsection{test-struct-init.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
struct FunStuff {
	string hello;
	int five;
}
FunStuff hi;

function test_if_malloc() int {
	hi = {hello = "hello"; five = 5;};
	return 5;
}

test_if_malloc();
if (hi.five == 5){
	println("MALLOC DOES WORK");
}

println(str_of_int(hi.five));
println(hi.hello);
\end{lstlisting}
\end{mdframed}
\subsubsection{test-struct-nested.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
name
\end{lstlisting}
\end{mdframed}
\subsubsection{test-struct-nested.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
struct Member {
    string name;
    int dob;
}

struct BankAccount {
    int accountNumber;
    Member member;
}

function nestedStruct() string {
    Member m1 = new(Member);
    m1.name = "name";
    m1.dob = 01012020;
    BankAccount a1 = new(BankAccount);
    a1.accountNumber = 4;
    a1.member = m1;

    return a1.member.name;
}

println(nestedStruct());
\end{lstlisting}
\end{mdframed}
\subsubsection{test-unop.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
Somebody once told me
the world is gonna roll me
I ain't the sharpest tool in the shed\end{lstlisting}
\end{mdframed}
\subsubsection{test-unop.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
bool x=true;
if (!x) {
 println("THIS SHOULDNT PRINT");
} else {
 println("Somebody once told me");
}

int y = -400;
if (y+400 == 0) {
 println("the world is gonna roll me");
}

float z = -4.5;
float c = -.3;
float b = z+c;
if(b==-4.8){
  println("I ain't the sharpest tool in the shed");
}

\end{lstlisting}
\end{mdframed}
\subsubsection{test-var-scope.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
9
10
10
10
10
10
10
10
10
10
10
8
\end{lstlisting}
\end{mdframed}
\subsubsection{test-var-scope.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
int q = 7;
if (q == 7) {
    int q = 9;
    println(str_of_int(q));
} else {
    println("no");
}

for (int i = 0; i < 10; i++) {
    int q = 9;
    println(str_of_int(q++));
}

function foo(int a) int {
    int q = 21;
    return a;
}

foo(7);

struct C {
    int q = 10;
}

C a = {q = 8;};
println(str_of_float(float_of_int(a.q)));
\end{lstlisting}
\end{mdframed}
\subsubsection{test-void-func.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
equal
not equal
okay
\end{lstlisting}
\end{mdframed}
\subsubsection{test-void-func.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
function thing(float p, float q) void {
    if (p == q) {
        println("equal");
    } else {
        println("not equal");
    }
    return;
}

thing(6.0989, 6.0989);


function more(int q, func(float, float; void) p, string h) void {
    float a = /*float_of_int(q);*/ 4.09;
    p(a, a*5.0);
    println(h);
    // no return
}

more(9, thing, "okay");
\end{lstlisting}
\end{mdframed}
\subsubsection{test-while-loop-int-incre.out}
\begin{mdframed}[hidealllines=true,backgroundcolor=green!10]
\begin{lstlisting}
0
1
2
\end{lstlisting}
\end{mdframed}
\subsubsection{test-while-loop-int-incre.shoo}
\begin{mdframed}[hidealllines=true,backgroundcolor=blue!10]
\begin{lstlisting}
int i = 0;
while (i < 3) {
    println(str_of_int(i));
    i++;
}\end{lstlisting}
\end{mdframed}
